---
phase: 01-foundation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00001_initial_schema.sql
autonomous: false

user_setup:
  - service: supabase
    why: "Auth Hook must be registered in Supabase Dashboard for custom JWT claims to work"
    dashboard_config:
      - task: "Register Auth Hook: Go to Authentication > Hooks > Custom Access Token > select public.custom_access_token_hook"
        location: "Supabase Dashboard > Authentication > Hooks"
      - task: "Enable Connection Pooling in Transaction mode: Go to Project Settings > Database > Connection Pooling > Enable > Set Pool Mode to Transaction"
        location: "Supabase Dashboard > Project Settings > Database > Connection Pooling"

must_haves:
  truths:
    - "All 9+ tables exist with correct columns, types, and constraints"
    - "RLS is enabled on EVERY table (zero tables with RLS disabled)"
    - "Every table with tenant_id has an index on tenant_id"
    - "RLS policies enforce tenant isolation via JWT app_metadata tenant_id"
    - "Super admin role can bypass tenant isolation policies"
    - "Auth Hook function injects user_role into JWT claims"
    - "Foreign key indexes exist for all relationship columns"
    - "Supabase connection pooling is enabled in Transaction mode for serverless compatibility (INFRA-04)"
  artifacts:
    - path: "supabase/migrations/00001_initial_schema.sql"
      provides: "Complete database schema with RLS"
      contains: "ENABLE ROW LEVEL SECURITY"
      min_lines: 200
  key_links:
    - from: "RLS policies"
      to: "auth.jwt() -> app_metadata"
      via: "JWT claim extraction in policy USING clause"
      pattern: "app_metadata.*tenant_id"
    - from: "custom_access_token_hook"
      to: "users.role"
      via: "Auth Hook injects role into JWT"
      pattern: "custom_access_token_hook"
    - from: "Supabase Dashboard > Authentication > Hooks"
      to: "public.custom_access_token_hook"
      via: "Dashboard registration activates the hook — without this step the function exists but never executes"
      pattern: "Custom Access Token"
    - from: "Supabase Dashboard > Connection Pooling"
      to: "Serverless function database connections"
      via: "Transaction mode pooling prevents connection exhaustion in serverless environments"
      pattern: "Transaction mode"
---

<objective>
Create the complete Supabase database migration with all tables, RLS policies, indexes, enums, and the Auth Hook function for custom JWT claims.

Purpose: This is the data layer foundation. Every feature depends on these tables existing with proper tenant isolation enforced at the database level. Getting RLS wrong means data breaches.

Output: A single comprehensive SQL migration file that creates the entire schema, ready to run against a Supabase project.
</objective>

<execution_context>
@/Users/aymanbaig/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aymanbaig/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create comprehensive database migration with RLS</name>
  <files>
    supabase/migrations/00001_initial_schema.sql
  </files>
  <action>
    Create the directory `supabase/migrations/` and write the complete migration SQL file. This single file creates the ENTIRE schema.

    **Order of operations in the migration:**
    1. Create enums (user_role, enrichment_status, list_member_status, activity_action_type)
    2. Create tables (in dependency order)
    3. Enable RLS on every table
    4. Create indexes on tenant_id and foreign key columns
    5. Create RLS policies for tenant isolation
    6. Create the Auth Hook function
    7. Create the authorize() helper function

    **Enums:**
    ```sql
    CREATE TYPE user_role AS ENUM ('super_admin', 'tenant_admin', 'agent', 'assistant');
    CREATE TYPE enrichment_status AS ENUM ('none', 'pending', 'in_progress', 'complete', 'failed');
    CREATE TYPE list_member_status AS ENUM ('new', 'contacted', 'responded', 'not_interested');
    CREATE TYPE activity_action_type AS ENUM (
      'login', 'search_executed', 'profile_viewed', 'profile_enriched',
      'add_to_list', 'remove_from_list', 'status_updated', 'note_added',
      'csv_exported', 'persona_created', 'lookalike_search'
    );
    ```

    **Tables (create in this order):**

    1. **tenants** — root entity, no foreign keys
       - id (uuid, PK, default gen_random_uuid())
       - name (text, NOT NULL)
       - slug (text, NOT NULL, UNIQUE) — used in URL /[orgId]/
       - logo_url (text, nullable)
       - primary_color (text, NOT NULL, default '#d4af37')
       - secondary_color (text, NOT NULL, default '#f4d47f')
       - is_active (boolean, NOT NULL, default true)
       - created_at (timestamptz, NOT NULL, default now())
       - updated_at (timestamptz, NOT NULL, default now())

    2. **users** — references auth.users and tenants
       - id (uuid, PK, references auth.users(id) ON DELETE CASCADE)
       - tenant_id (uuid, nullable, references tenants(id) ON DELETE CASCADE) — null for super_admin
       - email (text, NOT NULL)
       - full_name (text, NOT NULL)
       - role (user_role, NOT NULL, default 'assistant')
       - is_active (boolean, NOT NULL, default true)
       - created_at (timestamptz, NOT NULL, default now())
       - updated_at (timestamptz, NOT NULL, default now())

    3. **personas** — references tenants and users
       - id (uuid, PK, default gen_random_uuid())
       - tenant_id (uuid, NOT NULL, references tenants(id) ON DELETE CASCADE)
       - name (text, NOT NULL)
       - description (text, nullable)
       - filters (jsonb, NOT NULL, default '{}')
       - is_starter (boolean, NOT NULL, default false)
       - created_by (uuid, NOT NULL, references users(id))
       - last_used_at (timestamptz, nullable)
       - created_at (timestamptz, NOT NULL, default now())
       - updated_at (timestamptz, NOT NULL, default now())

    4. **prospects** — references tenants
       - id (uuid, PK, default gen_random_uuid())
       - tenant_id (uuid, NOT NULL, references tenants(id) ON DELETE CASCADE)
       - apollo_id (text, nullable)
       - first_name (text, NOT NULL)
       - last_name (text, NOT NULL)
       - full_name (text, NOT NULL, generated always as (first_name || ' ' || last_name) stored)
       - title (text, nullable)
       - company (text, nullable)
       - location (text, nullable)
       - work_email (text, nullable)
       - work_phone (text, nullable)
       - personal_email (text, nullable)
       - personal_phone (text, nullable)
       - linkedin_url (text, nullable)
       - enrichment_status (enrichment_status, NOT NULL, default 'none')
       - enriched_at (timestamptz, nullable)
       - created_at (timestamptz, NOT NULL, default now())
       - updated_at (timestamptz, NOT NULL, default now())
       - UNIQUE(tenant_id, work_email) WHERE work_email IS NOT NULL
       - UNIQUE(tenant_id, linkedin_url) WHERE linkedin_url IS NOT NULL

    5. **sec_transactions** — references prospects and tenants
       - id (uuid, PK, default gen_random_uuid())
       - prospect_id (uuid, NOT NULL, references prospects(id) ON DELETE CASCADE)
       - tenant_id (uuid, NOT NULL, references tenants(id) ON DELETE CASCADE)
       - transaction_date (date, NOT NULL)
       - security_title (text, NOT NULL)
       - transaction_type (text, NOT NULL)
       - transaction_shares (numeric, NOT NULL)
       - price_per_share (numeric, NOT NULL)
       - transaction_value (numeric, NOT NULL)
       - filing_url (text, nullable)
       - created_at (timestamptz, NOT NULL, default now())

    6. **prospect_summaries** — references prospects and tenants
       - id (uuid, PK, default gen_random_uuid())
       - prospect_id (uuid, NOT NULL, references prospects(id) ON DELETE CASCADE)
       - tenant_id (uuid, NOT NULL, references tenants(id) ON DELETE CASCADE)
       - summary_text (text, NOT NULL)
       - generated_at (timestamptz, NOT NULL, default now())
       - model_used (text, NOT NULL, default 'claude-3-haiku')
       - token_count (integer, NOT NULL, default 0)
       - created_at (timestamptz, NOT NULL, default now())

    7. **lists** — references tenants and users
       - id (uuid, PK, default gen_random_uuid())
       - tenant_id (uuid, NOT NULL, references tenants(id) ON DELETE CASCADE)
       - name (text, NOT NULL)
       - description (text, nullable)
       - created_by (uuid, NOT NULL, references users(id))
       - member_count (integer, NOT NULL, default 0)
       - created_at (timestamptz, NOT NULL, default now())
       - updated_at (timestamptz, NOT NULL, default now())

    8. **list_members** — junction table, references lists, prospects, tenants
       - id (uuid, PK, default gen_random_uuid())
       - list_id (uuid, NOT NULL, references lists(id) ON DELETE CASCADE)
       - prospect_id (uuid, NOT NULL, references prospects(id) ON DELETE CASCADE)
       - tenant_id (uuid, NOT NULL, references tenants(id) ON DELETE CASCADE)
       - status (list_member_status, NOT NULL, default 'new')
       - notes (text, nullable)
       - added_by (uuid, NOT NULL, references users(id))
       - created_at (timestamptz, NOT NULL, default now())
       - updated_at (timestamptz, NOT NULL, default now())
       - UNIQUE(list_id, prospect_id)

    9. **activity_log** — references tenants and users
       - id (uuid, PK, default gen_random_uuid())
       - tenant_id (uuid, NOT NULL, references tenants(id) ON DELETE CASCADE)
       - user_id (uuid, NOT NULL, references users(id))
       - action_type (activity_action_type, NOT NULL)
       - target_type (text, nullable)
       - target_id (uuid, nullable)
       - metadata (jsonb, nullable)
       - created_at (timestamptz, NOT NULL, default now())

    10. **usage_metrics_daily** — references tenants and users
        - id (uuid, PK, default gen_random_uuid())
        - tenant_id (uuid, NOT NULL, references tenants(id) ON DELETE CASCADE)
        - user_id (uuid, NOT NULL, references users(id))
        - date (date, NOT NULL)
        - logins (integer, NOT NULL, default 0)
        - searches (integer, NOT NULL, default 0)
        - profiles_viewed (integer, NOT NULL, default 0)
        - profiles_enriched (integer, NOT NULL, default 0)
        - csv_exports (integer, NOT NULL, default 0)
        - lists_created (integer, NOT NULL, default 0)
        - created_at (timestamptz, NOT NULL, default now())
        - updated_at (timestamptz, NOT NULL, default now())
        - UNIQUE(tenant_id, user_id, date)

    **RLS — CRITICAL: Enable on EVERY table immediately after creation:**
    ```sql
    ALTER TABLE tenants ENABLE ROW LEVEL SECURITY;
    ALTER TABLE users ENABLE ROW LEVEL SECURITY;
    -- ... etc for ALL tables
    ```

    **Indexes — Create on tenant_id and ALL foreign key columns:**
    ```sql
    CREATE INDEX idx_users_tenant_id ON users(tenant_id);
    CREATE INDEX idx_personas_tenant_id ON personas(tenant_id);
    CREATE INDEX idx_prospects_tenant_id ON prospects(tenant_id);
    CREATE INDEX idx_sec_transactions_tenant_id ON sec_transactions(tenant_id);
    CREATE INDEX idx_sec_transactions_prospect_id ON sec_transactions(prospect_id);
    CREATE INDEX idx_prospect_summaries_tenant_id ON prospect_summaries(tenant_id);
    CREATE INDEX idx_prospect_summaries_prospect_id ON prospect_summaries(prospect_id);
    CREATE INDEX idx_lists_tenant_id ON lists(tenant_id);
    CREATE INDEX idx_list_members_tenant_id ON list_members(tenant_id);
    CREATE INDEX idx_list_members_list_id ON list_members(list_id);
    CREATE INDEX idx_list_members_prospect_id ON list_members(prospect_id);
    CREATE INDEX idx_activity_log_tenant_id ON activity_log(tenant_id);
    CREATE INDEX idx_activity_log_user_id ON activity_log(user_id);
    CREATE INDEX idx_activity_log_action_type ON activity_log(action_type);
    CREATE INDEX idx_activity_log_created_at ON activity_log(created_at);
    CREATE INDEX idx_usage_metrics_daily_tenant_id ON usage_metrics_daily(tenant_id);
    CREATE INDEX idx_usage_metrics_daily_user_id ON usage_metrics_daily(user_id);
    CREATE INDEX idx_usage_metrics_daily_date ON usage_metrics_daily(date);
    ```

    **RLS Policies — Two patterns:**

    A) **Tenant tables (users, personas, prospects, etc.):**
    For SELECT/INSERT/UPDATE/DELETE, use:
    ```sql
    -- Regular users: access own tenant data only
    CREATE POLICY "tenant_isolation_select" ON table_name
      FOR SELECT USING (
        tenant_id = (auth.jwt() -> 'app_metadata' ->> 'tenant_id')::uuid
      );

    -- For INSERT, use WITH CHECK:
    CREATE POLICY "tenant_isolation_insert" ON table_name
      FOR INSERT WITH CHECK (
        tenant_id = (auth.jwt() -> 'app_metadata' ->> 'tenant_id')::uuid
      );

    -- For UPDATE:
    CREATE POLICY "tenant_isolation_update" ON table_name
      FOR UPDATE USING (
        tenant_id = (auth.jwt() -> 'app_metadata' ->> 'tenant_id')::uuid
      );

    -- For DELETE (tenant_admin+ only):
    CREATE POLICY "tenant_isolation_delete" ON table_name
      FOR DELETE USING (
        tenant_id = (auth.jwt() -> 'app_metadata' ->> 'tenant_id')::uuid
        AND (auth.jwt() -> 'app_metadata' ->> 'role')::text IN ('tenant_admin', 'super_admin')
      );
    ```

    B) **Super admin bypass policies (for /admin panel operations):**
    ```sql
    -- Super admins can access ALL data across tenants
    CREATE POLICY "super_admin_all_access" ON table_name
      FOR ALL USING (
        (auth.jwt() -> 'app_metadata' ->> 'role')::text = 'super_admin'
      );
    ```

    C) **Tenants table special policies:**
    - Regular users: SELECT own tenant only (by id matching their app_metadata tenant_id)
    - Super admin: ALL access

    D) **Users table special policies:**
    - Users can SELECT their own row always
    - Users can SELECT other users in their tenant
    - Super admin: ALL access

    E) **Assistant read-only enforcement:**
    For tables where assistants should be read-only, add condition to INSERT/UPDATE/DELETE policies:
    ```sql
    AND (auth.jwt() -> 'app_metadata' ->> 'role')::text != 'assistant'
    ```

    **Auth Hook function:**
    ```sql
    CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
    RETURNS jsonb
    LANGUAGE plpgsql
    STABLE
    AS $$
    DECLARE
      claims jsonb;
      user_tenant_id uuid;
      user_role text;
    BEGIN
      -- Fetch user role and tenant_id from public.users
      SELECT u.role::text, u.tenant_id
      INTO user_role, user_tenant_id
      FROM public.users u
      WHERE u.id = (event->>'user_id')::uuid;

      -- Get existing claims
      claims := event->'claims';

      -- Set custom claims in app_metadata
      IF user_role IS NOT NULL THEN
        claims := jsonb_set(claims, '{app_metadata}',
          COALESCE(claims->'app_metadata', '{}'::jsonb) ||
          jsonb_build_object(
            'role', user_role,
            'tenant_id', user_tenant_id
          )
        );
      END IF;

      -- Return modified event
      event := jsonb_set(event, '{claims}', claims);
      RETURN event;
    END;
    $$;

    -- Grant necessary permissions for the hook
    GRANT USAGE ON SCHEMA public TO supabase_auth_admin;
    GRANT SELECT ON public.users TO supabase_auth_admin;
    GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;

    -- Revoke function access from public/anon (security)
    REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM authenticated, anon, public;
    ```

    **Authorize helper function:**
    ```sql
    CREATE OR REPLACE FUNCTION public.authorize(required_role user_role)
    RETURNS boolean
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path = public
    AS $$
    BEGIN
      RETURN (
        SELECT
          CASE
            WHEN required_role = 'assistant' THEN true
            WHEN required_role = 'agent' THEN u.role IN ('agent', 'tenant_admin', 'super_admin')
            WHEN required_role = 'tenant_admin' THEN u.role IN ('tenant_admin', 'super_admin')
            WHEN required_role = 'super_admin' THEN u.role = 'super_admin'
            ELSE false
          END
        FROM public.users u
        WHERE u.id = auth.uid()
      );
    END;
    $$;
    ```

    **Updated_at trigger:**
    Create a reusable trigger function and apply to all tables with updated_at:
    ```sql
    CREATE OR REPLACE FUNCTION update_updated_at()
    RETURNS TRIGGER AS $$
    BEGIN
      NEW.updated_at = now();
      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    -- Apply to all tables with updated_at
    CREATE TRIGGER set_updated_at BEFORE UPDATE ON tenants
      FOR EACH ROW EXECUTE FUNCTION update_updated_at();
    -- ... repeat for users, personas, prospects, lists, list_members, usage_metrics_daily
    ```

    IMPORTANT:
    - Use gen_random_uuid() for UUID defaults (built into Postgres 13+)
    - Use timestamptz (not timestamp) for all time columns
    - Every policy MUST reference auth.jwt() -> 'app_metadata' for tenant_id and role
    - NEVER use auth.jwt() -> 'user_metadata' (user-modifiable, insecure)
    - The full_name column on prospects should be a GENERATED ALWAYS AS column
    - Include comments in SQL for clarity
    - After migration runs, the Auth Hook function exists in the database but is NOT active until registered in the Supabase Dashboard (see Task 2 below)
  </action>
  <verify>
    Review the SQL file for:
    1. All 10 tables created (tenants, users, personas, prospects, sec_transactions, prospect_summaries, lists, list_members, activity_log, usage_metrics_daily)
    2. RLS enabled on every table (grep for "ENABLE ROW LEVEL SECURITY" — should match table count)
    3. Index on tenant_id for every table that has one (grep for "idx_.*_tenant_id")
    4. RLS policies exist for SELECT/INSERT/UPDATE/DELETE on every tenant-scoped table
    5. Super admin bypass policy on every table
    6. Auth Hook function exists with correct grants
    7. Authorize helper function exists
    8. Updated_at triggers on all tables with updated_at column
    9. NO references to user_metadata for authorization
    10. File is valid SQL (no syntax errors visible)
  </verify>
  <done>
    Complete database migration file exists with all 10 tables, RLS enabled on every table, indexes on all tenant_id and foreign key columns, RLS policies enforcing tenant isolation via JWT app_metadata, super admin bypass policies, Auth Hook for custom JWT claims, authorize() helper function, and updated_at triggers. Ready to run against Supabase SQL editor or via CLI migration.
  </done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 2: Register Auth Hook in Supabase Dashboard</name>
  <action>
    The custom_access_token_hook function has been created by the migration, but it will NOT execute until it is registered in the Supabase Dashboard. This is a required manual step — there is no CLI/API to register Auth Hooks.
  </action>
  <how-to-verify>
    1. Open Supabase Dashboard for your project
    2. Navigate to: Authentication > Hooks
    3. Find "Custom Access Token" hook
    4. Select the hook function: `public.custom_access_token_hook`
    5. Enable the hook
    6. Save changes
    7. Verify: Sign in with a test user, inspect the JWT (via Supabase Auth debug or browser dev tools). Confirm `app_metadata` contains `role` and `tenant_id` fields injected by the hook.
  </how-to-verify>
  <resume-signal>Type "registered" once the Auth Hook is enabled in the Supabase Dashboard, or describe any issues.</resume-signal>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 3: Enable Supabase Connection Pooling (Transaction Mode)</name>
  <action>
    Supabase connection pooling must be enabled in Transaction mode for serverless compatibility (INFRA-04). Without this, serverless functions on Vercel will exhaust database connections under load because each invocation opens a new connection that may not be reused. There is no CLI/API to configure connection pooling — it must be done in the Supabase Dashboard.
  </action>
  <how-to-verify>
    1. Open Supabase Dashboard for your project
    2. Navigate to: Project Settings > Database > Connection Pooling
    3. Enable connection pooling if not already enabled
    4. Set Pool Mode to **Transaction** (NOT Session — Session mode holds connections open, defeating the purpose for serverless)
    5. Save changes
    6. Note the pooled connection string (port 6543) — this is the connection string the app should use in production. The direct connection string (port 5432) bypasses the pooler and should only be used for migrations.
    7. Verify: The Connection Pooling section shows "Enabled" with mode "Transaction"
  </how-to-verify>
  <resume-signal>Type "pooling-enabled" once connection pooling is set to Transaction mode in the Supabase Dashboard, or describe any issues.</resume-signal>
</task>

</tasks>

<verification>
1. Migration file exists at supabase/migrations/00001_initial_schema.sql
2. File contains CREATE TABLE for all 10 tables
3. Every table has ALTER TABLE ... ENABLE ROW LEVEL SECURITY
4. Every table with tenant_id has CREATE INDEX idx_..._tenant_id
5. Every table has at least one RLS policy
6. Auth Hook function custom_access_token_hook exists
7. Authorize helper function exists
8. No references to user_metadata for auth/authorization
9. Auth Hook registered in Supabase Dashboard (Authentication > Hooks > Custom Access Token > public.custom_access_token_hook enabled)
10. Connection pooling enabled in Transaction mode in Supabase Dashboard (Project Settings > Database > Connection Pooling)
</verification>

<success_criteria>
- All 10 tables defined with correct columns, types, and constraints
- RLS enabled on 100% of tables (query: SELECT tablename FROM pg_tables WHERE schemaname = 'public' AND rowsecurity = false should return 0 rows)
- Indexes exist on all tenant_id columns and foreign keys
- Auth Hook injects role and tenant_id into JWT app_metadata
- Super admin can access data across all tenants via RLS bypass policy
- Assistant role cannot INSERT/UPDATE/DELETE (read-only enforcement)
- Connection pooling enabled in Transaction mode for serverless compatibility (INFRA-04)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
