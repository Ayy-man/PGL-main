---
phase: 01-foundation
plan: 04
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - src/lib/auth/session.ts
  - src/lib/auth/rbac.ts
  - src/app/api/auth/callback/route.ts
  - src/app/(auth)/login/page.tsx
  - src/app/(auth)/layout.tsx
autonomous: true

must_haves:
  truths:
    - "Users can sign in with email/password via Supabase Auth"
    - "getCurrentUser() returns user with role and tenant_id from JWT claims"
    - "requireRole() throws redirect if user lacks minimum role"
    - "Auth callback handles Supabase auth code exchange"
    - "Login page renders with email/password form"
    - "Session persists across browser refresh"
  artifacts:
    - path: "src/lib/auth/session.ts"
      provides: "Session management with getCurrentUser and requireAuth"
      exports: ["getCurrentUser", "requireAuth"]
    - path: "src/lib/auth/rbac.ts"
      provides: "Role-based access control utilities"
      exports: ["requireRole", "checkPermission"]
    - path: "src/app/api/auth/callback/route.ts"
      provides: "Supabase auth callback handler"
      exports: ["GET"]
    - path: "src/app/(auth)/login/page.tsx"
      provides: "Login page with email/password form"
      contains: "signInWithPassword"
    - path: "src/app/(auth)/layout.tsx"
      provides: "Auth layout (minimal, no sidebar)"
  key_links:
    - from: "src/lib/auth/session.ts"
      to: "src/lib/supabase/server.ts"
      via: "createClient() for server-side auth checks"
      pattern: "createClient"
    - from: "src/app/(auth)/login/page.tsx"
      to: "src/lib/supabase/client.ts"
      via: "Browser client for signInWithPassword"
      pattern: "signInWithPassword"
    - from: "src/app/api/auth/callback/route.ts"
      to: "src/lib/supabase/server.ts"
      via: "Server client for code exchange"
      pattern: "exchangeCodeForSession"
---

<objective>
Build the authentication system: session management utilities, RBAC helpers, auth callback route, and login page.

Purpose: Authentication is the gateway for all user interactions. Users must sign in before accessing any tenant-scoped routes. The session utilities and RBAC helpers are used by every protected page and API route.

Output: Working login flow, session management, and role-based access control utilities.
</objective>

<execution_context>
@/Users/aymanbaig/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aymanbaig/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session management and RBAC utilities</name>
  <files>
    src/lib/auth/session.ts
    src/lib/auth/rbac.ts
  </files>
  <action>
    1. **src/lib/auth/session.ts** — Server-side session management:

       ```typescript
       import { createClient } from "@/lib/supabase/server";
       import { redirect } from "next/navigation";
       import type { SessionUser } from "@/types/auth";
       import type { UserRole } from "@/types/auth";

       /**
        * Get the current authenticated user with role and tenant context.
        * Returns null if not authenticated.
        * Use in Server Components and Route Handlers.
        *
        * IMPORTANT: Uses getUser() not getSession() — getUser() validates
        * the JWT with Supabase servers, getSession() uses cached data.
        */
       export async function getCurrentUser(): Promise<SessionUser | null> {
         const supabase = await createClient();
         const { data: { user }, error } = await supabase.auth.getUser();

         if (error || !user) return null;

         // Extract custom claims from app_metadata
         const role = (user.app_metadata?.role as UserRole) || 'assistant';
         const tenantId = user.app_metadata?.tenant_id as string | null;

         return {
           id: user.id,
           email: user.email!,
           role,
           tenantId: tenantId || null,
           fullName: user.user_metadata?.full_name || user.email!,
         };
       }

       /**
        * Require authentication. Redirects to login if not authenticated.
        * Use at the top of protected Server Components.
        */
       export async function requireAuth(): Promise<SessionUser> {
         const user = await getCurrentUser();
         if (!user) {
           redirect("/login");
         }
         return user;
       }

       /**
        * Require authentication AND tenant context.
        * Redirects to login if not authenticated.
        * Returns 404 if user has no tenant (unless super_admin).
        */
       export async function requireTenantUser(orgId: string): Promise<SessionUser> {
         const user = await requireAuth();

         // Super admins can access any tenant
         if (user.role === 'super_admin') return user;

         // Regular users must belong to the requested tenant
         if (user.tenantId !== orgId) {
           redirect("/login");
         }

         return user;
       }

       /**
        * Sign out the current user.
        */
       export async function signOut(): Promise<void> {
         const supabase = await createClient();
         await supabase.auth.signOut();
       }
       ```

    2. **src/lib/auth/rbac.ts** — Role-based access control:

       ```typescript
       import { redirect } from "next/navigation";
       import { getCurrentUser } from "./session";
       import {
         type UserRole,
         type SessionUser,
         hasMinRole,
         ROLE_PERMISSIONS,
       } from "@/types/auth";

       /**
        * Require a minimum role level. Redirects to appropriate page if insufficient.
        * Use in Server Components for page-level authorization.
        *
        * Example: await requireRole('tenant_admin');
        */
       export async function requireRole(minimumRole: UserRole): Promise<SessionUser> {
         const user = await getCurrentUser();

         if (!user) {
           redirect("/login");
         }

         if (!hasMinRole(user.role, minimumRole)) {
           // Insufficient permissions — redirect to dashboard (not login)
           if (user.tenantId) {
             redirect(`/${user.tenantId}`);
           }
           redirect("/login");
         }

         return user;
       }

       /**
        * Check if user has a specific permission.
        * Returns boolean (does not redirect).
        * Use for conditional UI rendering in Server Components.
        */
       export function checkPermission(
         user: SessionUser,
         permission: keyof typeof ROLE_PERMISSIONS.assistant
       ): boolean {
         return ROLE_PERMISSIONS[user.role][permission];
       }

       /**
        * Require super admin role specifically.
        * Redirects to login if not super admin.
        */
       export async function requireSuperAdmin(): Promise<SessionUser> {
         const user = await getCurrentUser();

         if (!user || user.role !== 'super_admin') {
           redirect("/login");
         }

         return user;
       }
       ```

    IMPORTANT:
    - Use getUser() (NOT getSession()) in server code — research confirms getUser() validates JWT, getSession() uses cached data
    - Extract role from app_metadata (NOT user_metadata) — user_metadata is user-modifiable
    - All functions are async and intended for Server Components / Route Handlers only
  </action>
  <verify>
    Run `npx tsc --noEmit` — no TypeScript errors.
    Verify getCurrentUser reads from app_metadata (not user_metadata) for role and tenant_id.
    Grep for "getSession" in src/lib/auth/ — should return 0 matches.
    Grep for "user_metadata.*role" in src/lib/auth/ — should return 0 matches.
  </verify>
  <done>
    Session management (getCurrentUser, requireAuth, requireTenantUser) and RBAC (requireRole, checkPermission, requireSuperAdmin) utilities created. All use getUser() for JWT validation, extract authorization data from app_metadata only.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create auth callback route and login page</name>
  <files>
    src/app/api/auth/callback/route.ts
    src/app/(auth)/login/page.tsx
    src/app/(auth)/layout.tsx
  </files>
  <action>
    1. **src/app/api/auth/callback/route.ts** — Supabase auth callback:

       ```typescript
       import { createClient } from "@/lib/supabase/server";
       import { NextResponse } from "next/server";

       export async function GET(request: Request) {
         const { searchParams, origin } = new URL(request.url);
         const code = searchParams.get("code");
         const next = searchParams.get("next") ?? "/";

         if (code) {
           const supabase = await createClient();
           const { error } = await supabase.auth.exchangeCodeForSession(code);

           if (!error) {
             // After successful auth, get user to determine redirect
             const { data: { user } } = await supabase.auth.getUser();
             const tenantId = user?.app_metadata?.tenant_id;
             const role = user?.app_metadata?.role;

             // Super admin goes to /admin, tenant users go to /[orgId]
             if (role === 'super_admin') {
               return NextResponse.redirect(`${origin}/admin`);
             }
             if (tenantId) {
               return NextResponse.redirect(`${origin}/${tenantId}`);
             }
             return NextResponse.redirect(`${origin}${next}`);
           }
         }

         // Auth error — redirect to login with error
         return NextResponse.redirect(`${origin}/login?error=auth_callback_failed`);
       }
       ```

    2. **src/app/(auth)/layout.tsx** — Minimal auth layout (no sidebar):

       ```typescript
       export default function AuthLayout({
         children,
       }: {
         children: React.ReactNode;
       }) {
         return (
           <div className="flex min-h-screen items-center justify-center bg-background">
             <div className="w-full max-w-md px-4">
               {children}
             </div>
           </div>
         );
       }
       ```

    3. **src/app/(auth)/login/page.tsx** — Login page with email/password form:

       This is a Client Component because it uses form state and Supabase browser client.

       ```typescript
       "use client";

       import { useState } from "react";
       import { useRouter } from "next/navigation";
       import { createClient } from "@/lib/supabase/client";

       export default function LoginPage() {
         const [email, setEmail] = useState("");
         const [password, setPassword] = useState("");
         const [error, setError] = useState<string | null>(null);
         const [loading, setLoading] = useState(false);
         const router = useRouter();

         async function handleSubmit(e: React.FormEvent) {
           e.preventDefault();
           setError(null);
           setLoading(true);

           try {
             const supabase = createClient();
             const { data, error: authError } = await supabase.auth.signInWithPassword({
               email,
               password,
             });

             if (authError) {
               setError(authError.message);
               return;
             }

             if (data.user) {
               const tenantId = data.user.app_metadata?.tenant_id;
               const role = data.user.app_metadata?.role;

               // Redirect based on role
               if (role === 'super_admin') {
                 router.push("/admin");
               } else if (tenantId) {
                 router.push(`/${tenantId}`);
               } else {
                 setError("No tenant assigned. Contact your administrator.");
               }
               router.refresh();
             }
           } catch {
             setError("An unexpected error occurred");
           } finally {
             setLoading(false);
           }
         }

         return (
           <div className="space-y-6">
             <div className="space-y-2 text-center">
               <h1 className="font-serif text-3xl font-bold tracking-tight">
                 Welcome Back
               </h1>
               <p className="text-muted-foreground">
                 Sign in to your account
               </p>
             </div>

             <form onSubmit={handleSubmit} className="space-y-4">
               {error && (
                 <div className="rounded-md bg-destructive/10 p-3 text-sm text-destructive">
                   {error}
                 </div>
               )}

               <div className="space-y-2">
                 <label htmlFor="email" className="text-sm font-medium">
                   Email
                 </label>
                 <input
                   id="email"
                   type="email"
                   value={email}
                   onChange={(e) => setEmail(e.target.value)}
                   placeholder="you@example.com"
                   required
                   disabled={loading}
                   className="flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50"
                 />
               </div>

               <div className="space-y-2">
                 <label htmlFor="password" className="text-sm font-medium">
                   Password
                 </label>
                 <input
                   id="password"
                   type="password"
                   value={password}
                   onChange={(e) => setPassword(e.target.value)}
                   placeholder="Enter your password"
                   required
                   disabled={loading}
                   className="flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50"
                 />
               </div>

               <button
                 type="submit"
                 disabled={loading}
                 className="inline-flex h-10 w-full items-center justify-center rounded-md bg-primary px-4 py-2 text-sm font-medium text-primary-foreground ring-offset-background transition-colors hover:bg-primary/90 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50"
               >
                 {loading ? "Signing in..." : "Sign In"}
               </button>
             </form>
           </div>
         );
       }
       ```

    The login page uses the browser Supabase client (createClient from @/lib/supabase/client) for signInWithPassword. After successful login, it reads app_metadata to determine redirect (super_admin -> /admin, tenant user -> /[tenantId]).

    DO NOT use shadcn Button/Input components yet (they may not be installed). Use plain HTML elements with Tailwind classes that match the shadcn style system.
    DO NOT add a signup page — users are created by super admins only.
  </action>
  <verify>
    Run `npx tsc --noEmit` — no TypeScript errors.
    Verify src/app/api/auth/callback/route.ts exports GET function.
    Verify src/app/(auth)/login/page.tsx has "use client" directive.
    Verify login page uses signInWithPassword (not signUp or magic link).
    Verify auth callback uses getUser() (not getSession()).
  </verify>
  <done>
    Auth callback route handles Supabase code exchange with role-based redirect. Login page renders email/password form with error handling and loading states. Auth layout provides centered minimal layout. Login redirects super_admin to /admin and tenant users to /[tenantId].
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Session utilities use getUser() not getSession()
3. Auth data extracted from app_metadata not user_metadata
4. Login page uses browser client with signInWithPassword
5. Auth callback handles code exchange and role-based redirect
6. RBAC utilities enforce role hierarchy correctly
</verification>

<success_criteria>
- getCurrentUser() returns SessionUser with role and tenantId from JWT app_metadata
- requireAuth() redirects unauthenticated users to /login
- requireRole('tenant_admin') redirects users with insufficient role
- Login form submits email/password via Supabase Auth
- After login, user redirects to appropriate route based on role
- Session persists across browser refresh (handled by Supabase cookie management)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
