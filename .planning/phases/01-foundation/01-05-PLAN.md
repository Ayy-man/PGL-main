---
phase: 01-foundation
plan: 05
type: execute
wave: 2
depends_on: ["01-02"]
files_modified:
  - src/middleware.ts
  - src/lib/validations/schemas.ts
autonomous: true

must_haves:
  truths:
    - "Middleware extracts orgId from /[orgId]/... URL paths and sets x-tenant-id header"
    - "Middleware refreshes Supabase auth session on every request"
    - "Unauthenticated requests to protected routes redirect to /login"
    - "/admin routes are accessible without tenant context"
    - "/(auth) routes bypass auth checks"
    - "Static assets and API routes are excluded from middleware"
  artifacts:
    - path: "src/middleware.ts"
      provides: "Multi-tenant middleware with auth session refresh"
      exports: ["middleware", "config"]
      min_lines: 40
    - path: "src/lib/validations/schemas.ts"
      provides: "Zod validation schemas for common inputs"
      exports: ["tenantSlugSchema", "emailSchema", "uuidSchema"]
  key_links:
    - from: "src/middleware.ts"
      to: "src/lib/supabase/middleware.ts"
      via: "createClient for session refresh"
      pattern: "createClient"
    - from: "src/middleware.ts"
      to: "x-tenant-id header"
      via: "Header injection for downstream Server Components"
      pattern: "x-tenant-id"
    - from: "Server Components (e.g. src/app/[orgId]/layout.tsx)"
      to: "x-tenant-id header"
      via: "headers().get('x-tenant-id') reads tenant context set by middleware, then validates against user.app_metadata.tenant_id and uses tenant_id to scope all Supabase queries"
      pattern: "headers\\(\\).*x-tenant-id"
---

<objective>
Create the Next.js middleware for multi-tenant routing, auth session refresh, and request validation. Also create reusable Zod validation schemas.

Purpose: Middleware is the first code that runs on every request. It extracts tenant context from URLs, refreshes auth sessions (critical for Supabase cookie-based auth), and protects routes from unauthenticated access.

Output: Working middleware that handles tenant extraction and auth, plus reusable validation schemas.
</objective>

<execution_context>
@/Users/aymanbaig/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aymanbaig/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create multi-tenant middleware with auth session refresh</name>
  <files>
    src/middleware.ts
  </files>
  <action>
    Create the root middleware file at `src/middleware.ts` (NOT in src/app/ — middleware.ts goes at src/ root for App Router).

    The middleware must handle:

    1. **Session refresh** — Call supabase.auth.getUser() to refresh auth cookies. This is CRITICAL for Supabase cookie-based auth to work. Without this, sessions expire silently.

    2. **Route classification** — Determine route type:
       - Public routes: `/login`, `/(auth)/*` — skip auth check
       - Admin routes: `/admin/*` — require auth but no tenant context
       - Tenant routes: `/[orgId]/*` — require auth AND extract tenant context
       - API routes: `/api/*` — pass through (individual routes handle their own auth)
       - Static: `/_next/*`, `/favicon.ico` — skip entirely

    3. **Tenant extraction** — For paths matching `/[orgId]/...`, extract the first path segment as the orgId. Set it as a response header `x-tenant-id` so Server Components can read it.

    4. **Auth redirect** — If user is not authenticated and route is protected, redirect to `/login?redirect={original_path}`.

    5. **Role-based routing** — If authenticated user tries to access `/admin` without super_admin role, redirect to their tenant dashboard. If a user tries to access a tenant they don't belong to, redirect to their own tenant.

    ```typescript
    import { createClient } from "@/lib/supabase/middleware";
    import { NextResponse } from "next/server";
    import type { NextRequest } from "next/server";

    // Routes that don't require authentication
    const PUBLIC_ROUTES = ["/login", "/signup", "/auth/callback"];

    // Routes that are admin-only
    const ADMIN_ROUTES = ["/admin"];

    export async function middleware(request: NextRequest) {
      let response = NextResponse.next({
        request: {
          headers: request.headers,
        },
      });

      const supabase = createClient(request, response);
      const pathname = request.nextUrl.pathname;

      // Skip public routes
      if (PUBLIC_ROUTES.some((route) => pathname.startsWith(route))) {
        // Still refresh session for public routes (cookie refresh)
        await supabase.auth.getUser();
        return response;
      }

      // Refresh session and get user
      const { data: { user } } = await supabase.auth.getUser();

      // Redirect unauthenticated users to login
      if (!user) {
        const loginUrl = new URL("/login", request.url);
        loginUrl.searchParams.set("redirect", pathname);
        return NextResponse.redirect(loginUrl);
      }

      const role = user.app_metadata?.role;
      const userTenantId = user.app_metadata?.tenant_id;

      // Handle /admin routes
      if (pathname.startsWith("/admin")) {
        if (role !== "super_admin") {
          // Non-admins redirected to their tenant
          if (userTenantId) {
            return NextResponse.redirect(new URL(`/${userTenantId}`, request.url));
          }
          return NextResponse.redirect(new URL("/login", request.url));
        }
        return response;
      }

      // Handle root path — redirect to appropriate location
      if (pathname === "/") {
        if (role === "super_admin") {
          return NextResponse.redirect(new URL("/admin", request.url));
        }
        if (userTenantId) {
          return NextResponse.redirect(new URL(`/${userTenantId}`, request.url));
        }
        return NextResponse.redirect(new URL("/login", request.url));
      }

      // Extract orgId from path-based routing: /[orgId]/...
      const pathSegments = pathname.split("/").filter(Boolean);
      const orgId = pathSegments[0];

      if (orgId) {
        // Tenant context validation
        // Super admins can access any tenant
        if (role !== "super_admin" && userTenantId !== orgId) {
          // User trying to access a tenant they don't belong to
          if (userTenantId) {
            return NextResponse.redirect(new URL(`/${userTenantId}`, request.url));
          }
          return NextResponse.redirect(new URL("/login", request.url));
        }

        // Set tenant context header for downstream Server Components
        response.headers.set("x-tenant-id", orgId);
      }

      return response;
    }

    export const config = {
      matcher: [
        /*
         * Match all request paths except:
         * - _next/static (static files)
         * - _next/image (image optimization files)
         * - favicon.ico (favicon file)
         * - public folder assets (svg, png, jpg, etc.)
         * - api/auth/callback (Supabase auth callback)
         */
        "/((?!_next/static|_next/image|favicon.ico|api/auth/callback|.*\\.(?:svg|png|jpg|jpeg|gif|webp|ico)$).*)",
      ],
    };
    ```

    IMPORTANT:
    - Use getUser() (NOT getSession()) — research explicitly warns against getSession() in server code
    - Keep middleware LIGHTWEIGHT — no database queries, no heavy computation (Edge Runtime limitations)
    - The matcher must exclude static assets, images, and the auth callback route
    - Always refresh session even on public routes (for cookie expiration management)
    - DO NOT query the database in middleware to validate tenant existence — that happens in the [orgId]/layout.tsx Server Component

    **Downstream consumption pattern (for future plans):**
    Server Components in `src/app/[orgId]/layout.tsx` will read this header and validate tenant context:
    ```typescript
    import { headers } from "next/headers";
    import { createClient } from "@/lib/supabase/server";

    // In a Server Component:
    const headersList = await headers();
    const tenantId = headersList.get("x-tenant-id");
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    const userTenantId = user?.app_metadata?.tenant_id;

    // Validate: middleware-set tenant matches user's JWT claim
    if (tenantId && userTenantId && tenantId !== userTenantId) {
      redirect(`/${userTenantId}`); // Redirect to user's own tenant
    }

    // All downstream queries use tenantId for scoping
    // (RLS enforces this at DB level, but explicit scoping prevents leaks)
    const { data } = await supabase
      .from("prospects")
      .select("*")
      .eq("tenant_id", tenantId);
    ```
    This wiring ensures the middleware-injected x-tenant-id header is read, validated against the authenticated user's JWT tenant_id claim, and used to scope all data queries. RLS provides the security backstop at the database level.
  </action>
  <verify>
    Run `npx tsc --noEmit` — no TypeScript errors.
    Verify middleware.ts is at src/middleware.ts (not src/app/middleware.ts).
    Grep for "getSession" in src/middleware.ts — should return 0 matches.
    Verify x-tenant-id header is set for tenant routes.
    Verify /admin routes check for super_admin role.
    Verify matcher excludes static assets.
  </verify>
  <done>
    Middleware handles auth session refresh on every request, extracts tenant context from URL paths, protects routes from unauthenticated access, enforces role-based route access (admin routes require super_admin), and injects x-tenant-id header for downstream consumption.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create reusable Zod validation schemas</name>
  <files>
    src/lib/validations/schemas.ts
  </files>
  <action>
    Create src/lib/validations/schemas.ts with reusable validation schemas for common input types:

    ```typescript
    import { z } from "zod";

    // UUID validation
    export const uuidSchema = z.string().uuid("Invalid UUID format");

    // Email validation
    export const emailSchema = z.string().email("Invalid email address").toLowerCase();

    // Tenant slug validation (URL-safe, lowercase)
    export const tenantSlugSchema = z
      .string()
      .min(2, "Slug must be at least 2 characters")
      .max(50, "Slug must be at most 50 characters")
      .regex(/^[a-z0-9][a-z0-9-]*[a-z0-9]$/, "Slug must be lowercase alphanumeric with hyphens, cannot start or end with hyphen");

    // Tenant creation
    export const createTenantSchema = z.object({
      name: z.string().min(1, "Name is required").max(100),
      slug: tenantSlugSchema,
      logo_url: z.string().url().nullable().optional(),
      primary_color: z.string().regex(/^#[0-9a-fA-F]{6}$/, "Must be hex color").default("#d4af37"),
      secondary_color: z.string().regex(/^#[0-9a-fA-F]{6}$/, "Must be hex color").default("#f4d47f"),
    });

    // User invitation
    export const inviteUserSchema = z.object({
      email: emailSchema,
      full_name: z.string().min(1, "Name is required").max(100),
      role: z.enum(["tenant_admin", "agent", "assistant"]),
      tenant_id: uuidSchema,
    });

    // Login form
    export const loginSchema = z.object({
      email: emailSchema,
      password: z.string().min(6, "Password must be at least 6 characters"),
    });

    // Pagination
    export const paginationSchema = z.object({
      page: z.coerce.number().int().min(1).default(1),
      limit: z.coerce.number().int().min(1).max(100).default(50),
    });

    // Search/filter
    export const searchSchema = z.object({
      query: z.string().max(200).optional(),
      sort_by: z.string().optional(),
      sort_order: z.enum(["asc", "desc"]).default("desc"),
    });

    // Type exports for form usage
    export type CreateTenantInput = z.infer<typeof createTenantSchema>;
    export type InviteUserInput = z.infer<typeof inviteUserSchema>;
    export type LoginInput = z.infer<typeof loginSchema>;
    export type PaginationInput = z.infer<typeof paginationSchema>;
    export type SearchInput = z.infer<typeof searchSchema>;
    ```

    These schemas will be used by:
    - Server Actions for form validation
    - Route Handlers for request body validation
    - Client-side form validation (shared schemas)
  </action>
  <verify>
    Run `npx tsc --noEmit` — no TypeScript errors.
    Verify all schemas are exported with their inferred types.
  </verify>
  <done>
    Reusable Zod schemas created for UUID, email, tenant slug, tenant creation, user invitation, login, pagination, and search. Each exports both the schema and the inferred TypeScript type.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Middleware at correct location (src/middleware.ts)
3. Middleware uses getUser() not getSession()
4. x-tenant-id header set for tenant routes
5. Public routes don't require auth
6. /admin routes require super_admin role
7. Validation schemas compile and export types
</verification>

<success_criteria>
- Middleware intercepts all non-static requests
- Auth session refreshed on every request (Supabase cookie management)
- Tenant context extracted from URL and injected as header
- Unauthenticated users redirected to /login with redirect parameter
- Super admin routed to /admin, tenant users to /[tenantId]
- Validation schemas available for use in forms and API routes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-05-SUMMARY.md`
</output>
