---
phase: 01-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/supabase/client.ts
  - src/lib/supabase/server.ts
  - src/lib/supabase/middleware.ts
  - src/lib/supabase/admin.ts
  - src/lib/redis/client.ts
  - src/lib/cache/keys.ts
autonomous: true

must_haves:
  truths:
    - "Browser client can be created for Client Components using anon key"
    - "Server client can be created for Server Components with cookie-based session"
    - "Middleware client can be created for Next.js middleware with request/response cookies"
    - "Admin client uses service role key and is only importable in server code"
    - "Redis client connects via HTTP (serverless-compatible)"
    - "Cache keys are always prefixed with tenant:tenantId:"
  artifacts:
    - path: "src/lib/supabase/client.ts"
      provides: "Browser Supabase client for Client Components"
      exports: ["createClient"]
    - path: "src/lib/supabase/server.ts"
      provides: "Server Supabase client for Server Components and Route Handlers"
      exports: ["createClient"]
    - path: "src/lib/supabase/middleware.ts"
      provides: "Middleware Supabase client"
      exports: ["createClient"]
    - path: "src/lib/supabase/admin.ts"
      provides: "Admin Supabase client with service role key"
      exports: ["createAdminClient"]
    - path: "src/lib/redis/client.ts"
      provides: "Upstash Redis singleton client"
      exports: ["getRedisClient"]
    - path: "src/lib/cache/keys.ts"
      provides: "Tenant-scoped cache key helper"
      exports: ["getTenantCacheKey"]
  key_links:
    - from: "src/lib/supabase/client.ts"
      to: "NEXT_PUBLIC_SUPABASE_URL"
      via: "createBrowserClient with anon key"
      pattern: "createBrowserClient"
    - from: "src/lib/supabase/server.ts"
      to: "cookies from next/headers"
      via: "createServerClient with cookie handlers"
      pattern: "cookieStore\\.getAll"
    - from: "src/lib/cache/keys.ts"
      to: "Redis operations"
      via: "tenant-prefixed key generation"
      pattern: "tenant:"
---

<objective>
Create the three Supabase client patterns (browser, server, middleware), an admin client for service-role operations, a Redis client singleton, and tenant-scoped cache key helpers.

Purpose: These clients are the data access foundation for all subsequent plans. Every auth check, database query, and cache operation flows through these clients.

Output: 6 client/utility files in src/lib/ ready for import by auth, middleware, and feature code.
</objective>

<execution_context>
@/Users/aymanbaig/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aymanbaig/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase client files (browser, server, middleware, admin)</name>
  <files>
    src/lib/supabase/client.ts
    src/lib/supabase/server.ts
    src/lib/supabase/middleware.ts
    src/lib/supabase/admin.ts
  </files>
  <action>
    Create four Supabase client files following the exact patterns from the research document.

    1. **src/lib/supabase/client.ts** — Browser client for Client Components:
       ```typescript
       import { createBrowserClient } from "@supabase/ssr";

       export function createClient() {
         return createBrowserClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL!,
           process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
         );
       }
       ```
       - Uses anon key (safe for browser)
       - No cookie handling needed (browser manages cookies)

    2. **src/lib/supabase/server.ts** — Server client for Server Components and Route Handlers:
       ```typescript
       import { createServerClient } from "@supabase/ssr";
       import { cookies } from "next/headers";

       export async function createClient() {
         const cookieStore = await cookies();

         return createServerClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL!,
           process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
           {
             cookies: {
               getAll() {
                 return cookieStore.getAll();
               },
               setAll(cookiesToSet) {
                 try {
                   cookiesToSet.forEach(({ name, value, options }) =>
                     cookieStore.set(name, value, options)
                   );
                 } catch {
                   // Ignore: setAll called from Server Component (read-only context)
                 }
               },
             },
           }
         );
       }
       ```
       - Uses `cookies()` from next/headers
       - setAll wrapped in try/catch for Server Component context (read-only)
       - Uses anon key (RLS enforced)

    3. **src/lib/supabase/middleware.ts** — Middleware client:
       ```typescript
       import { createServerClient } from "@supabase/ssr";
       import { NextResponse, type NextRequest } from "next/server";

       export function createClient(request: NextRequest, response: NextResponse) {
         return createServerClient(
           process.env.NEXT_PUBLIC_SUPABASE_URL!,
           process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
           {
             cookies: {
               getAll() {
                 return request.cookies.getAll();
               },
               setAll(cookiesToSet) {
                 cookiesToSet.forEach(({ name, value, options }) => {
                   request.cookies.set(name, value);
                   response.cookies.set(name, value, options);
                 });
               },
             },
           }
         );
       }
       ```
       - Takes request and response as parameters
       - Sets cookies on both request (for downstream) and response (for browser)

    4. **src/lib/supabase/admin.ts** — Admin client with service role key:
       ```typescript
       import { createClient } from "@supabase/supabase-js";

       // WARNING: This client bypasses RLS. Use ONLY in server-side code
       // (Route Handlers, Server Actions) for admin operations like
       // user management and tenant provisioning.
       // NEVER import this file in Client Components.

       export function createAdminClient() {
         const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
         const key = process.env.SUPABASE_SERVICE_ROLE_KEY;

         if (!url || !key) {
           throw new Error(
             "Missing SUPABASE_SERVICE_ROLE_KEY or NEXT_PUBLIC_SUPABASE_URL"
           );
         }

         return createClient(url, key, {
           auth: {
             autoRefreshToken: false,
             persistSession: false,
           },
         });
       }
       ```
       - Uses service role key (bypasses RLS)
       - Disables autoRefresh and session persistence (server-only)
       - Strong warning comment about security

    Use ONLY `@supabase/ssr` for client/server/middleware. Use `@supabase/supabase-js` for admin.
    Do NOT use getSession() anywhere — research says use getClaims() or getUser() in server code.
  </action>
  <verify>
    Run `npx tsc --noEmit` — no TypeScript errors in any Supabase client file.
    Verify all 4 files exist and export their respective functions.
    Grep for "getSession" in src/lib/supabase/ — should return 0 matches.
    Grep for "service_role\|SERVICE_ROLE" in src/lib/supabase/client.ts — should return 0 matches (service role never in browser client).
  </verify>
  <done>
    Four Supabase client files created following official @supabase/ssr patterns. Browser client uses anon key, server client uses cookie-based session, middleware client handles request/response cookies, admin client uses service role key (server-only).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Redis client and tenant-scoped cache key helpers</name>
  <files>
    src/lib/redis/client.ts
    src/lib/cache/keys.ts
  </files>
  <action>
    1. **src/lib/redis/client.ts** — Upstash Redis singleton:
       ```typescript
       import { Redis } from "@upstash/redis";

       let redis: Redis | null = null;

       export function getRedisClient(): Redis {
         if (!redis) {
           if (!process.env.UPSTASH_REDIS_REST_URL || !process.env.UPSTASH_REDIS_REST_TOKEN) {
             throw new Error("Missing UPSTASH_REDIS_REST_URL or UPSTASH_REDIS_REST_TOKEN");
           }
           redis = Redis.fromEnv();
         }
         return redis;
       }
       ```
       - Singleton pattern (reuse across requests in same process)
       - Uses `Redis.fromEnv()` which reads UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN
       - HTTP-based (edge-compatible, no connection pooling needed)

    2. **src/lib/cache/keys.ts** — Tenant-scoped cache key helpers:
       ```typescript
       /**
        * Generate a tenant-scoped cache key.
        * ALL cache keys MUST go through this function to prevent
        * cross-tenant data bleed.
        *
        * Format: "tenant:{tenantId}:{resource}:{identifier}"
        *
        * Examples:
        *   getTenantCacheKey("abc-123", "prospects", "list:1:50")
        *   // => "tenant:abc-123:prospects:list:1:50"
        *
        *   getTenantCacheKey("abc-123", "persona", "finance-elite")
        *   // => "tenant:abc-123:persona:finance-elite"
        */
       export function getTenantCacheKey(
         tenantId: string,
         resource: string,
         identifier?: string
       ): string {
         if (!tenantId) {
           throw new Error("tenantId is required for cache key generation");
         }
         const parts = ["tenant", tenantId, resource];
         if (identifier) parts.push(identifier);
         return parts.join(":");
       }

       /**
        * Parse a tenant-scoped cache key back into its components.
        */
       export function parseTenantCacheKey(key: string): {
         tenantId: string;
         resource: string;
         identifier?: string;
       } | null {
         const parts = key.split(":");
         if (parts.length < 3 || parts[0] !== "tenant") return null;
         return {
           tenantId: parts[1],
           resource: parts[2],
           identifier: parts.length > 3 ? parts.slice(3).join(":") : undefined,
         };
       }
       ```

    The getTenantCacheKey function MUST throw if tenantId is empty/undefined — this catches accidental omissions that would cause cross-tenant data bleed.
  </action>
  <verify>
    Run `npx tsc --noEmit` — no TypeScript errors.
    Verify src/lib/redis/client.ts exports getRedisClient.
    Verify src/lib/cache/keys.ts exports getTenantCacheKey and parseTenantCacheKey.
    Verify getTenantCacheKey throws on empty tenantId (conceptually — actual test would be in a unit test).
  </verify>
  <done>
    Redis client singleton created with Upstash HTTP-based connection. Cache key helper enforces tenant:${tenantId}: prefix on all cache keys with runtime validation. Both are importable from @/lib/redis/client and @/lib/cache/keys.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. All 6 files exist in expected locations under src/lib/
3. No service role key usage in browser client file
4. No getSession() calls in any Supabase client file
5. Cache key helper enforces tenant prefix
</verification>

<success_criteria>
- Supabase browser client importable from @/lib/supabase/client
- Supabase server client importable from @/lib/supabase/server
- Supabase middleware client importable from @/lib/supabase/middleware
- Supabase admin client importable from @/lib/supabase/admin (service role, server-only)
- Redis client importable from @/lib/redis/client
- Cache key helper importable from @/lib/cache/keys
- All use correct patterns from research (no deprecated auth-helpers, no getSession)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
