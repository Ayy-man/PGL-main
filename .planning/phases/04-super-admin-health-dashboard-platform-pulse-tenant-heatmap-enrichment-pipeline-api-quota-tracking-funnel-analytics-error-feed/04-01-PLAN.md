---
phase: 04-super-admin-health-dashboard-platform-pulse-tenant-heatmap-enrichment-pipeline-api-quota-tracking-funnel-analytics-error-feed
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/inngest/functions/enrich-prospect.ts
  - src/lib/enrichment/track-api-usage.ts
  - src/lib/enrichment/contactout.ts
  - src/lib/enrichment/exa.ts
  - src/lib/enrichment/edgar.ts
  - src/lib/enrichment/claude.ts
  - src/lib/apollo/client.ts
autonomous: true
requirements:
  - "DESIGN.md Section: New Data Capture Required (enrichment error details + API quota usage)"
  - "DESIGN.md Section: Enrichment Pipeline stat card (rich error data)"
  - "DESIGN.md Section: API Quota Burn stat card (Redis counters)"

must_haves:
  truths:
    - "Enrichment failures store structured error objects with status, error message, and timestamp per source"
    - "Every successful API call to Apollo, ContactOut, Exa, EDGAR, and Claude increments a daily Redis counter"
    - "Redis quota counters have 90-day TTL and follow key pattern api_usage:{provider}:{YYYY-MM-DD}"
    - "Existing enrichment behavior is unchanged — quota tracking is fire-and-forget and never blocks enrichment"
  artifacts:
    - path: "src/inngest/functions/enrich-prospect.ts"
      provides: "Upgraded updateSourceStatus writing { status, error?, at } objects"
      contains: "status.*error.*at"
    - path: "src/lib/enrichment/track-api-usage.ts"
      provides: "Reusable Redis INCR utility for API quota tracking"
      exports: ["trackApiUsage"]
    - path: "src/lib/enrichment/contactout.ts"
      provides: "ContactOut client with API usage tracking"
      contains: "trackApiUsage"
    - path: "src/lib/enrichment/exa.ts"
      provides: "Exa client with API usage tracking"
      contains: "trackApiUsage"
    - path: "src/lib/enrichment/edgar.ts"
      provides: "EDGAR client with API usage tracking"
      contains: "trackApiUsage"
    - path: "src/lib/enrichment/claude.ts"
      provides: "Claude client with API usage tracking"
      contains: "trackApiUsage"
    - path: "src/lib/apollo/client.ts"
      provides: "Apollo client with API usage tracking"
      contains: "trackApiUsage"
  key_links:
    - from: "src/lib/enrichment/track-api-usage.ts"
      to: "src/lib/cache/redis.ts"
      via: "import { redis } from @/lib/cache/redis"
      pattern: "import.*redis.*from.*@/lib/cache/redis"
    - from: "src/inngest/functions/enrich-prospect.ts"
      to: "prospects.enrichment_source_status"
      via: "updateSourceStatus writes structured JSONB objects"
      pattern: "status.*error.*at.*toISOString"
---

<objective>
Upgrade enrichment data capture for the health dashboard: (1) modify updateSourceStatus in the Inngest enrichment function to write structured error objects (status, error message, timestamp) instead of plain strings, and (2) add Redis INCR instrumentation to all 5 API clients so daily usage counters are tracked.

Purpose: The health dashboard needs rich error details for the Error Feed and per-provider daily usage counts for the API Quota Burn card. Without this data capture, those dashboard sections have no data to display.

Output: Modified enrich-prospect.ts with richer error capture, new trackApiUsage utility, and 5 instrumented API clients.
</objective>

<execution_context>
@/Users/aymanbaig/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aymanbaig/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-super-admin-health-dashboard-platform-pulse-tenant-heatmap-enrichment-pipeline-api-quota-tracking-funnel-analytics-error-feed/DESIGN.md
@.planning/phases/04-super-admin-health-dashboard-platform-pulse-tenant-heatmap-enrichment-pipeline-api-quota-tracking-funnel-analytics-error-feed/04-RESEARCH.md
@src/inngest/functions/enrich-prospect.ts
@src/lib/cache/redis.ts
@src/lib/enrichment/contactout.ts
@src/lib/enrichment/exa.ts
@src/lib/enrichment/edgar.ts
@src/lib/enrichment/claude.ts
@src/lib/apollo/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Upgrade updateSourceStatus to write structured error objects</name>
  <files>src/inngest/functions/enrich-prospect.ts</files>
  <action>
Modify the `updateSourceStatus` function signature in `src/inngest/functions/enrich-prospect.ts`:

**Current signature:** `updateSourceStatus(prospectId: string, source: string, status: string)`
**New signature:** `updateSourceStatus(prospectId: string, source: string, payload: { status: string; error?: string; at: string })`

The function body stays the same (fetch current `enrichment_source_status`, merge new source entry, write back). The only change is that the `[source]` key now receives the full `{ status, error?, at }` object instead of a plain string.

Update ALL callers within `enrich-prospect.ts`:

1. **Success calls** (currently `await updateSourceStatus(prospectId, "contactout", "complete")`):
   Change to: `await updateSourceStatus(prospectId, "contactout", { status: "complete", at: new Date().toISOString() })`

2. **Failure calls** (currently `await updateSourceStatus(prospectId, "contactout", "failed")`):
   Change to: `await updateSourceStatus(prospectId, "contactout", { status: "failed", error: error instanceof Error ? error.message : String(error), at: new Date().toISOString() })`

3. **Special status calls** like `"circuit_open"` and `"skipped"` and `"pending"`:
   Change to: `{ status: "circuit_open", at: new Date().toISOString() }` / `{ status: "skipped", at: new Date().toISOString() }` / `{ status: "pending", at: new Date().toISOString() }`

4. **The initial `mark-in-progress` step** sets `enrichment_source_status` directly (not via `updateSourceStatus`). Update that inline object to use the structured shape:
   ```
   enrichment_source_status: {
     contactout: { status: "pending", at: new Date().toISOString() },
     exa: { status: "pending", at: new Date().toISOString() },
     sec: { status: "pending", at: new Date().toISOString() },
     claude: { status: "pending", at: new Date().toISOString() },
   }
   ```

Define a TypeScript type at the top of the file:
```typescript
type SourceStatusPayload = { status: string; error?: string; at: string };
```

**CRITICAL:** This is backward-compatible at the JSONB level. Old rows with string values like `"complete"` remain valid. The error feed API (Plan 02) will handle both shapes: `typeof entry === "string" ? { status: entry } : entry`. No database migration needed.

Do NOT change the function's event handling, step structure, or any other behavior. Only the status recording shape changes.
  </action>
  <verify>
    <automated>cd "/Users/aymanbaig/Desktop/Manual Library/Phronesis-main" && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
    <manual>Verify enrich-prospect.ts compiles and all updateSourceStatus calls pass structured objects</manual>
  </verify>
  <done>All updateSourceStatus calls in enrich-prospect.ts write { status, error?, at } objects. The SourceStatusPayload type is defined. The mark-in-progress step uses the structured shape. No behavioral changes to enrichment workflow.</done>
</task>

<task type="auto">
  <name>Task 2: Create trackApiUsage utility and instrument all 5 API clients</name>
  <files>
    src/lib/enrichment/track-api-usage.ts
    src/lib/enrichment/contactout.ts
    src/lib/enrichment/exa.ts
    src/lib/enrichment/edgar.ts
    src/lib/enrichment/claude.ts
    src/lib/apollo/client.ts
  </files>
  <action>
**Step A: Create `src/lib/enrichment/track-api-usage.ts`**

New file with a single exported function:

```typescript
import { redis } from "@/lib/cache/redis";

/**
 * Increment daily API usage counter for a provider.
 * Fire-and-forget — never throws, never blocks the caller.
 * Key pattern: api_usage:{provider}:{YYYY-MM-DD}
 * TTL: 90 days
 */
export async function trackApiUsage(
  provider: "apollo" | "contactout" | "exa" | "edgar" | "claude"
): Promise<void> {
  try {
    const today = new Date().toISOString().slice(0, 10);
    const key = `api_usage:${provider}:${today}`;
    const pipeline = redis.pipeline();
    pipeline.incr(key);
    pipeline.expire(key, 60 * 60 * 24 * 90); // 90-day TTL
    await pipeline.exec();
  } catch {
    // Non-critical — quota tracking must never block or throw
  }
}
```

**Step B: Instrument each API client**

For each of the 5 files below, add `import { trackApiUsage } from "@/lib/enrichment/track-api-usage";` and call `trackApiUsage("provider")` AFTER each successful API response (not in catch blocks, not before the call).

1. **`src/lib/apollo/client.ts`**: After the successful Apollo API fetch response (after checking `response.ok`), add `await trackApiUsage("apollo");` — but wrap it so it doesn't block. Use: `trackApiUsage("apollo").catch(() => {});` (fire-and-forget pattern). Place it after the response is parsed but before returning results.

2. **`src/lib/enrichment/contactout.ts`**: After successful ContactOut API response, add `trackApiUsage("contactout").catch(() => {});`

3. **`src/lib/enrichment/exa.ts`**: After successful Exa API response, add `trackApiUsage("exa").catch(() => {});`

4. **`src/lib/enrichment/edgar.ts`**: After successful SEC EDGAR API response, add `trackApiUsage("edgar").catch(() => {});`

5. **`src/lib/enrichment/claude.ts`**: After successful Claude API response, add `trackApiUsage("claude").catch(() => {});`

**CRITICAL rules:**
- Import from `@/lib/cache/redis` (the canonical singleton with lazy init), NOT from `@/lib/redis/client`.
- Use `.catch(() => {})` pattern so tracking failures never propagate.
- Place the call AFTER confirming the API call succeeded. Do NOT track failed or rate-limited calls.
- Do NOT modify any existing logic, error handling, or return values in the clients.
  </action>
  <verify>
    <automated>cd "/Users/aymanbaig/Desktop/Manual Library/Phronesis-main" && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
    <manual>Verify trackApiUsage is imported in all 5 clients and called after successful responses</manual>
  </verify>
  <done>New `track-api-usage.ts` utility exists with `trackApiUsage()`. All 5 API clients (apollo, contactout, exa, edgar, claude) import and call it after successful responses using fire-and-forget pattern. No existing behavior changed.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `grep -r "trackApiUsage" src/lib/enrichment/ src/lib/apollo/` shows 6 matches (1 definition + 5 call sites)
3. `grep "SourceStatusPayload" src/inngest/functions/enrich-prospect.ts` shows type definition
4. `grep -c "at: new Date" src/inngest/functions/enrich-prospect.ts` shows multiple structured calls
</verification>

<success_criteria>
- enrich-prospect.ts updateSourceStatus writes { status, error?, at } objects for all sources
- track-api-usage.ts exists with fire-and-forget Redis INCR per provider per day
- All 5 API clients call trackApiUsage after successful responses
- TypeScript compiles cleanly
- No behavioral changes to enrichment workflow or API clients
</success_criteria>

<output>
After completion, create `.planning/phases/04-super-admin-health-dashboard-platform-pulse-tenant-heatmap-enrichment-pipeline-api-quota-tracking-funnel-analytics-error-feed/04-01-SUMMARY.md`
</output>
