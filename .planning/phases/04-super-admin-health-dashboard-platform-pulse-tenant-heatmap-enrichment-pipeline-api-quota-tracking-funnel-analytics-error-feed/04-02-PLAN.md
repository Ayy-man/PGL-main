---
phase: 04-super-admin-health-dashboard-platform-pulse-tenant-heatmap-enrichment-pipeline-api-quota-tracking-funnel-analytics-error-feed
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/admin/dashboard/route.ts
  - src/app/api/admin/tenants/activity/route.ts
  - src/app/api/admin/enrichment/health/route.ts
  - src/app/api/admin/errors/route.ts
  - src/app/api/admin/funnel/route.ts
  - src/app/api/admin/quota/route.ts
autonomous: true
requirements:
  - "DESIGN.md Section: API Endpoints Needed (all 6 new routes)"
  - "DESIGN.md Section: Platform Pulse (data source queries)"
  - "DESIGN.md Section: Tenant Activity Heatmap (aggregated data)"
  - "DESIGN.md Section: Enrichment Pipeline Health graph (per-source breakdown)"
  - "DESIGN.md Section: Search-to-Export Funnel graph (activity_log aggregation)"
  - "DESIGN.md Section: Error/Failure Feed (failed enrichment query)"
  - "DESIGN.md Section: Coming Soon Cards (API Quota shell)"

must_haves:
  truths:
    - "Super admin can fetch platform pulse stats (total prospects, enrichment coverage %, failed count, active users today vs 7d avg)"
    - "Super admin can fetch tenant heatmap data with 7d aggregated searches, enrichments, exports, last active, and user count per tenant"
    - "Super admin can fetch enrichment health data broken down by source (contactout, exa, edgar, claude) and status (success/failed) per day"
    - "Super admin can fetch search-to-export funnel data with 4 stages from activity_log"
    - "Super admin can fetch recent enrichment failures with prospect name, user name, tenant, error details, and timestamp"
    - "API quota endpoint returns a Coming Soon response shell"
    - "Non-super-admin users receive 403 Forbidden on all admin API endpoints"
  artifacts:
    - path: "src/app/api/admin/dashboard/route.ts"
      provides: "Platform Pulse stats API"
      exports: ["GET"]
    - path: "src/app/api/admin/tenants/activity/route.ts"
      provides: "Tenant Heatmap data API"
      exports: ["GET"]
    - path: "src/app/api/admin/enrichment/health/route.ts"
      provides: "Enrichment pipeline health API"
      exports: ["GET"]
    - path: "src/app/api/admin/errors/route.ts"
      provides: "Error/failure feed API"
      exports: ["GET"]
    - path: "src/app/api/admin/funnel/route.ts"
      provides: "Search-to-export funnel API"
      exports: ["GET"]
    - path: "src/app/api/admin/quota/route.ts"
      provides: "API quota Coming Soon shell"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/admin/dashboard/route.ts"
      to: "supabase.prospects + activity_log + usage_metrics_daily"
      via: "createAdminClient() queries"
      pattern: "createAdminClient.*from.*prospects"
    - from: "src/app/api/admin/tenants/activity/route.ts"
      to: "supabase.tenants + usage_metrics_daily + users + activity_log"
      via: "createAdminClient() queries"
      pattern: "createAdminClient.*from.*tenants"
    - from: "src/app/api/admin/errors/route.ts"
      to: "supabase.prospects WHERE enrichment_status = failed"
      via: "createAdminClient() queries"
      pattern: "enrichment_status.*failed"
---

<objective>
Create 6 new API Route Handlers under `/api/admin/*` that serve data for the health dashboard. Each endpoint is guarded by super admin auth, uses `createAdminClient()` for cross-tenant reads, and returns JSON responses.

Purpose: The dashboard UI components (Plan 03-04) need real API endpoints to fetch data from. Building the API layer first ensures the UI is built against stable response shapes, not mock data.

Output: 6 new Route Handler files under `src/app/api/admin/` with complete query logic and response shapes.
</objective>

<execution_context>
@/Users/aymanbaig/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aymanbaig/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-super-admin-health-dashboard-platform-pulse-tenant-heatmap-enrichment-pipeline-api-quota-tracking-funnel-analytics-error-feed/DESIGN.md
@.planning/phases/04-super-admin-health-dashboard-platform-pulse-tenant-heatmap-enrichment-pipeline-api-quota-tracking-funnel-analytics-error-feed/04-RESEARCH.md
@src/app/api/admin/tenants/route.ts
@src/lib/supabase/admin.ts
@src/lib/auth/rbac.ts
@src/lib/auth/session.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dashboard, tenants/activity, and quota API routes</name>
  <files>
    src/app/api/admin/dashboard/route.ts
    src/app/api/admin/tenants/activity/route.ts
    src/app/api/admin/quota/route.ts
  </files>
  <action>
**Auth pattern for ALL new Route Handlers:** Do NOT use `requireSuperAdmin()` (it calls `redirect()` which can 500 in Route Handlers). Instead, inline the auth check per the research recommendation:

```typescript
import { createClient } from "@/lib/supabase/server";
const supabase = await createClient();
const { data: { user } } = await supabase.auth.getUser();
if (!user || user.app_metadata?.role !== "super_admin") {
  return NextResponse.json({ error: "Forbidden" }, { status: 403 });
}
```

All routes must have `export const dynamic = "force-dynamic";` at the top level.

**Route 1: `GET /api/admin/dashboard` — Platform Pulse Stats**

File: `src/app/api/admin/dashboard/route.ts`

Query logic using `createAdminClient()`:
1. `prospects` table: `SELECT enrichment_status` with `{ count: "exact" }` — compute total count, enriched count (status = "complete"), failed count (status = "failed"), and enrichment coverage percentage.
2. `activity_log` table: `SELECT DISTINCT user_id` WHERE `action_type = 'login'` AND `created_at >= today` — count for "active users today". Include `created_at >= today` date filter (critical for partitioned table performance per Research pitfall #2).
3. `usage_metrics_daily` table: `SELECT total_logins` WHERE `date >= 7 days ago` — sum and divide by 7 for "7-day average active users".

Response shape:
```json
{
  "totalProspects": 1250,
  "enrichmentCoverage": 72,
  "enrichmentFailed": 15,
  "activeUsersToday": 8,
  "activeUsers7dAvg": 6
}
```

**Route 2: `GET /api/admin/tenants/activity` — Tenant Heatmap**

File: `src/app/api/admin/tenants/activity/route.ts`

Query logic:
1. Fetch active tenants: `tenants WHERE is_active = true` — get id, name.
2. Fetch users per tenant: `users` — `SELECT id, full_name, tenant_id` filtered to active tenant IDs. This provides both user counts AND the user identity data needed for the per-user breakdown.
3. Fetch 7d usage metrics at TENANT level: `usage_metrics_daily WHERE date >= 7 days ago` — group by `tenant_id`, SUM `searches_executed`, `profiles_enriched`, `csv_exports`. This gives the tenant-level aggregate row.
4. Fetch 7d usage metrics at USER level: `usage_metrics_daily WHERE date >= 7 days ago` — `SELECT user_id, SUM(searches_executed), SUM(profiles_enriched), SUM(csv_exports)` grouped by `user_id`. This gives the per-user breakdown data.
5. Fetch last active per tenant: `activity_log` — `SELECT tenant_id, MAX(created_at)`. Include `created_at >= 90 days ago` to limit partition scan.

Aggregation: In-memory join of all 5 queries by tenant_id/user_id:
- For each tenant, compute `userCount` from the users array length.
- For each tenant, build the `users[]` array by matching users (from query 2) with their per-user usage metrics (from query 4). Each user entry includes `{ id, fullName, searches7d, enrichments7d, exports7d }`.
- Users with no usage_metrics_daily rows in the 7d window get zeros for all metric fields.
- Return array sorted by total searches descending (most active first).

Response shape:
```json
{
  "tenants": [
    {
      "id": "uuid",
      "name": "The W Team",
      "userCount": 5,
      "searches7d": 45,
      "enrichments7d": 12,
      "exports7d": 3,
      "lastActive": "2026-02-25T14:30:00Z",
      "users": [
        { "id": "uuid", "fullName": "John Doe", "searches7d": 20, "enrichments7d": 5, "exports7d": 1 }
      ]
    }
  ]
}
```

Include per-user breakdown in the response so the frontend can expand rows without extra API calls (per CONTEXT.md decision: "inline expansion").

**Route 3: `GET /api/admin/quota` — Coming Soon Shell**

File: `src/app/api/admin/quota/route.ts`

Return a static JSON response:
```json
{
  "status": "coming_soon",
  "message": "API quota tracking will be available after Redis instrumentation is deployed",
  "providers": ["apollo", "contactout", "exa", "edgar", "claude"]
}
```

This is a placeholder. Once Plan 01's Redis INCR instrumentation is deployed and populated, this endpoint can be updated to read `api_usage:{provider}:{date}` keys from Redis. For now it returns the shell so the UI can render the "Coming Soon" card.
  </action>
  <verify>
    <automated>cd "/Users/aymanbaig/Desktop/Manual Library/Phronesis-main" && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
    <manual>Verify all 3 route files exist and export GET handlers with inline super_admin auth check</manual>
  </verify>
  <done>Three API routes created: /api/admin/dashboard returns pulse stats, /api/admin/tenants/activity returns heatmap data with per-user breakdown, /api/admin/quota returns Coming Soon shell. All guarded with inline super_admin check.</done>
</task>

<task type="auto">
  <name>Task 2: Create enrichment/health, funnel, and errors API routes</name>
  <files>
    src/app/api/admin/enrichment/health/route.ts
    src/app/api/admin/funnel/route.ts
    src/app/api/admin/errors/route.ts
  </files>
  <action>
Same auth pattern as Task 1 (inline super_admin check, `force-dynamic`, `createAdminClient()`).

**Route 4: `GET /api/admin/enrichment/health?days=14` — Per-Source Breakdown**

File: `src/app/api/admin/enrichment/health/route.ts`

Accept optional `days` query param (default 14, max 90).

Query: `prospects` table — `SELECT enrichment_source_status, updated_at` WHERE `enrichment_source_status IS NOT NULL` AND `updated_at >= cutoff`.

In-memory aggregation (consistent with Phase 3 pattern — in-memory aggregation in Inngest functions):
- Group by `date(updated_at)` x `source` x `status`
- Handle BOTH string entries (backward compat: `"complete"` -> success, `"failed"` -> failed) and object entries (`{ status: "complete" }` -> success, `{ status: "failed" }` -> failed). Use: `const status = typeof entry === "string" ? entry : entry.status;`
- Flatten to array for Recharts consumption.

Response shape:
```json
{
  "data": [
    {
      "date": "2026-02-25",
      "contactout_success": 12, "contactout_failed": 2,
      "exa_success": 10, "exa_failed": 1,
      "edgar_success": 5, "edgar_failed": 0,
      "claude_success": 15, "claude_failed": 3
    }
  ],
  "days": 14
}
```

**Route 5: `GET /api/admin/funnel?days=7` — Search-to-Export Funnel**

File: `src/app/api/admin/funnel/route.ts`

Accept optional `days` query param (default 7, max 90).

Query: `activity_log` table — `SELECT action_type, COUNT(*)` WHERE `action_type IN ('search_executed', 'profile_viewed', 'profile_enriched', 'csv_exported')` AND `created_at >= cutoff` GROUP BY `action_type`.

Since Supabase JS client doesn't support GROUP BY + COUNT natively, use in-memory aggregation: fetch all matching rows (with limit to prevent huge reads — max 10,000 rows) and count by action_type in JS.

Response shape:
```json
{
  "data": [
    { "stage": "Searches", "value": 340 },
    { "stage": "Profile Views", "value": 210 },
    { "stage": "Enrichments", "value": 87 },
    { "stage": "Exports", "value": 24 }
  ],
  "days": 7
}
```

Always return all 4 stages even if count is 0. Order: searches -> profile views -> enrichments -> exports.

**Route 6: `GET /api/admin/errors?limit=50&page=1` — Error Feed**

File: `src/app/api/admin/errors/route.ts`

Accept optional `limit` (default 50, max 100) and `page` (default 1) query params.

Query: `prospects` table — `SELECT id, full_name, enrichment_status, enrichment_source_status, updated_at, tenant_id, user_id` WHERE `enrichment_status = 'failed'` AND `updated_at >= 7 days ago`. Order by `updated_at DESC`. Use `.range()` for pagination.

For tenant name: make a separate query to `tenants` table to fetch `id, name` for all active tenants, then join in-memory by `tenant_id`. This avoids complex Supabase foreign key joins.

For user name (DESIGN.md Section 4 requires a "User" column): make a separate query to `users` table to fetch `id, full_name` for the distinct `user_id` values from the prospects result set, then join in-memory by `user_id`. This shows which user triggered the enrichment that failed.

Handle both string and object entries in `enrichment_source_status` for the detail expansion:
- If entry is a string: return `{ status: entry }`
- If entry is an object: return as-is (includes `error` and `at` fields)

Response shape:
```json
{
  "data": [
    {
      "id": "uuid",
      "fullName": "Jane Doe",
      "userName": "John Smith",
      "tenantName": "The W Team",
      "tenantId": "uuid",
      "enrichmentStatus": "failed",
      "sourceDetails": {
        "contactout": { "status": "complete", "at": "2026-02-25T..." },
        "exa": { "status": "failed", "error": "429 Too Many Requests", "at": "2026-02-25T..." }
      },
      "updatedAt": "2026-02-25T14:30:00Z"
    }
  ],
  "total": 15,
  "page": 1,
  "limit": 50
}
```

Note: Per CONTEXT.md locked decision — NO re-trigger button on error feed. This is view-only. The API does not need a POST/PUT endpoint for re-triggering.
  </action>
  <verify>
    <automated>cd "/Users/aymanbaig/Desktop/Manual Library/Phronesis-main" && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
    <manual>Verify all 3 route files exist, export GET handlers, and handle backward-compatible enrichment_source_status shapes</manual>
  </verify>
  <done>Three API routes created: /api/admin/enrichment/health returns per-source daily breakdown, /api/admin/funnel returns 4-stage funnel counts, /api/admin/errors returns paginated failed enrichments with per-source error details and userName field (from users table join). All handle both string and object enrichment_source_status entries.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. All 6 route files exist under `src/app/api/admin/`
3. Every route has `export const dynamic = "force-dynamic"`
4. Every route has inline super_admin auth check (not requireSuperAdmin())
5. Every route uses `createAdminClient()` for cross-tenant queries
6. enrichment/health and errors routes handle both string and object enrichment_source_status entries
</verification>

<success_criteria>
- 6 new API Route Handlers exist and compile
- All routes enforce super_admin access with 403 on unauthorized
- Dashboard route returns prospect counts, enrichment coverage %, active users
- Tenants/activity route returns per-tenant 7d aggregates with per-user breakdown
- Enrichment/health route returns per-source success/fail counts by day
- Funnel route returns 4-stage funnel data from activity_log
- Errors route returns paginated failed enrichments with source details
- Quota route returns Coming Soon shell response
</success_criteria>

<output>
After completion, create `.planning/phases/04-super-admin-health-dashboard-platform-pulse-tenant-heatmap-enrichment-pipeline-api-quota-tracking-funnel-analytics-error-feed/04-02-SUMMARY.md`
</output>
