---
phase: 02-persona-search-lists
plan: 03
type: tdd
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/app/api/search/apollo/route.ts
  - src/lib/apollo/client.ts
  - src/lib/apollo/__tests__/client.test.ts
autonomous: true
user_setup:
  - service: apollo-io
    why: "People Search API for prospect discovery"
    env_vars:
      - name: APOLLO_API_KEY
        source: "Apollo.io Dashboard -> Settings -> Integrations -> API -> API Key"

must_haves:
  truths:
    - "POST /api/search/apollo accepts personaId, page, pageSize and returns Apollo results"
    - "Invalid requests return 400 with Zod validation errors"
    - "Unauthenticated requests return 401"
    - "Rate-limited requests return 429 with reset time"
    - "Cached results return immediately without calling Apollo API"
    - "Apollo results include pagination metadata (totalPages, hasMore)"
    - "Persona filters correctly translate to Apollo API parameters"
  artifacts:
    - path: "src/app/api/search/apollo/route.ts"
      provides: "POST handler for Apollo People Search"
      exports: ["POST"]
    - path: "src/lib/apollo/client.ts"
      provides: "Apollo API client with caching, rate limiting, circuit breaking"
      exports: ["searchApollo"]
    - path: "src/lib/apollo/__tests__/client.test.ts"
      provides: "Tests for Apollo client filter translation and pagination"
  key_links:
    - from: "src/app/api/search/apollo/route.ts"
      to: "src/lib/apollo/client.ts"
      via: "Route calls searchApollo function"
      pattern: "import.*searchApollo.*from.*apollo/client"
    - from: "src/lib/apollo/client.ts"
      to: "src/lib/circuit-breaker/apollo-breaker.ts"
      via: "Client uses circuit breaker for API calls"
      pattern: "import.*apolloBreaker.*from.*circuit-breaker"
    - from: "src/lib/apollo/client.ts"
      to: "src/lib/cache/keys.ts"
      via: "Client uses tenant-scoped cache"
      pattern: "import.*getCachedData.*setCachedData.*from.*cache/keys"
    - from: "src/lib/apollo/client.ts"
      to: "src/lib/rate-limit/limiters.ts"
      via: "Client checks rate limit before API call"
      pattern: "import.*apolloRateLimiter.*from.*rate-limit"
    - from: "src/app/api/search/apollo/route.ts"
      to: "src/lib/personas/queries.ts"
      via: "Route fetches persona filters from database"
      pattern: "import.*getPersonaById.*from.*personas/queries"
---

<objective>
Build the Apollo.io search API route and client library using TDD. The client translates persona filters to Apollo API parameters, applies rate limiting, caching, and circuit breaking. The route handler validates requests, authenticates users, and returns paginated results.

Purpose: This is the core search capability of the platform. Users select a persona and get matching prospects from Apollo.io. Rate limiting prevents $1000+ bills, caching reduces API calls by ~80%, and the circuit breaker prevents cascading failures.

Output: API route at POST /api/search/apollo, Apollo client library with searchApollo function, and tests for filter translation and pagination logic.
</objective>

<execution_context>
@/Users/aymanbaig/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aymanbaig/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-persona-search-lists/02-RESEARCH.md
@.planning/phases/02-persona-search-lists/02-01-SUMMARY.md
@.planning/phases/02-persona-search-lists/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Apollo client with filter translation, caching, rate limiting, and circuit breaking</name>
  <files>
    src/lib/apollo/client.ts
    src/lib/apollo/__tests__/client.test.ts
  </files>
  <action>
**TDD approach: Write tests first, then implement.**

Create `src/lib/apollo/__tests__/client.test.ts`:
- Test `translateFiltersToApolloParams(filters: PersonaFilters)`:
  - Input: `{ titles: ["CEO", "CFO"], seniorities: ["c_suite"], industries: ["Finance"], locations: ["New York"], companySize: ["51-200"], keywords: "private equity" }`
  - Expected output: `{ person_titles: ["CEO", "CFO"], person_seniorities: ["c_suite"], organization_industries: ["Finance"], person_locations: ["New York"], organization_num_employees_ranges: ["51-200"], q_keywords: "private equity" }`
  - Test with empty/undefined filters — should produce params with only defined fields (no undefined values sent to Apollo)
  - Test that empty arrays are excluded from output
- Test `calculatePagination(totalEntries: number, page: number, perPage: number)`:
  - Input: totalEntries=150, page=1, perPage=50 -> `{ page: 1, pageSize: 50, totalPages: 3, totalResults: 150, hasMore: true }`
  - Input: totalEntries=150, page=3, perPage=50 -> `{ hasMore: false }`
  - Input: totalEntries=50000, page=1, perPage=100 -> `{ totalPages: 500 }` (capped at 500, not 500)
  - Input: totalEntries=0, page=1, perPage=50 -> `{ totalPages: 0, hasMore: false }`

Run tests — they MUST fail (RED phase).

Create `src/lib/apollo/client.ts`:
- Export `translateFiltersToApolloParams(filters: PersonaFilters): Partial<ApolloSearchParams>` — maps PersonaFilters fields to Apollo API parameter names. Only include fields that are defined and non-empty.
- Export `calculatePagination(totalEntries: number, page: number, perPage: number): { page: number; pageSize: number; totalPages: number; totalResults: number; hasMore: boolean }` — caps totalPages at 500 (Apollo's limit).
- Export `searchApollo(tenantId: string, personaId: string, filters: PersonaFilters, page: number, pageSize: number): Promise<{ people: ApolloPerson[]; pagination: {...}; cached: boolean }>`:
  1. Check rate limit: `apolloRateLimiter.limit(\`tenant:${tenantId}\`)` — if not success, throw RateLimitError
  2. Check cache: `getCachedData({ tenantId, resource: "apollo:search", identifier: { personaId, page, pageSize } })` — if hit, return with `cached: true`
  3. Build Apollo params: `{ ...translateFiltersToApolloParams(filters), page, per_page: pageSize }`
  4. Call `apolloBreaker.fire(apolloParams)` — circuit breaker wraps the actual API call
  5. Cache results: `setCachedData(cacheKey, response, 86400)` (24h TTL)
  6. Calculate pagination from response
  7. Return `{ people: response.people, pagination, cached: false }`
- Export custom error classes: `RateLimitError` (with resetAt), `ApolloApiError` (with status code)

Run tests again — they MUST pass (GREEN phase).

IMPORTANT: The `translateFiltersToApolloParams` function must handle the mapping correctly:
- `titles` -> `person_titles`
- `seniorities` -> `person_seniorities`
- `industries` -> `organization_industries`
- `locations` -> `person_locations`
- `companySize` -> `organization_num_employees_ranges`
- `keywords` -> `q_keywords`
  </action>
  <verify>
Run `pnpm test src/lib/apollo/__tests__/client.test.ts` — all tests pass.
Run `pnpm tsc --noEmit` — no type errors.
Verify filter translation maps all 6 fields correctly.
Verify pagination caps at 500 pages.
  </verify>
  <done>
Apollo client translates persona filters to Apollo API params (tested). Pagination capped at 500 pages (tested). searchApollo function integrates rate limiting, caching, and circuit breaking. Custom error classes for rate limit and API errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create POST /api/search/apollo route handler</name>
  <files>
    src/app/api/search/apollo/route.ts
  </files>
  <action>
Create `src/app/api/search/apollo/route.ts`:

Export `POST` handler with this flow:

1. **Parse and validate request body** with `searchRequestSchema` from `@/lib/apollo/schemas`:
   - On failure: return 400 with `{ error: "Invalid request", details: zodError.format() }`

2. **Authenticate user**:
   - Create Supabase server client
   - Get user: `const { data: { user } } = await supabase.auth.getUser()`
   - If no user: return 401 with `{ error: "Unauthorized" }`
   - Extract `tenantId` from `user.app_metadata.tenant_id`
   - If no tenantId: return 403 with `{ error: "No tenant associated" }`

3. **Fetch persona from database**:
   - `const persona = await getPersonaById(personaId, tenantId)`
   - If not found: return 404 with `{ error: "Persona not found" }`

4. **Update persona last used timestamp**:
   - `await updatePersonaLastUsed(personaId, tenantId)` (fire-and-forget, don't block response)

5. **Call searchApollo**:
   - `const result = await searchApollo(tenantId, personaId, persona.filters, page, pageSize)`
   - Return 200 with result

6. **Error handling**:
   - `RateLimitError`: return 429 with `{ error: "Rate limit exceeded", resetAt: error.resetAt }` + rate limit headers
   - `ApolloApiError`: return 503 with `{ error: "Search service temporarily unavailable" }`
   - Unknown errors: return 500 with `{ error: "Internal server error" }` + log error

Response shape:
```json
{
  "people": [...],
  "pagination": {
    "page": 1,
    "pageSize": 50,
    "totalPages": 3,
    "totalResults": 150,
    "hasMore": true
  },
  "cached": false
}
```

Set response headers:
- `Cache-Control: no-store` (prevent browser caching of API responses — we manage caching server-side)
- Rate limit headers when applicable
  </action>
  <verify>
Run `pnpm tsc --noEmit` — no type errors.
Run `pnpm build` — route compiles.
Verify route file:
- Has `export async function POST` (not GET)
- Uses `supabase.auth.getUser()` for auth (not getSession — getUser validates with server)
- Extracts tenant_id from `app_metadata` (not from URL or request body)
- Returns proper HTTP status codes (400, 401, 403, 404, 429, 503, 500)
  </verify>
  <done>
POST /api/search/apollo route validates input, authenticates user, fetches persona, calls Apollo with rate limiting + caching + circuit breaking, returns paginated results. All error cases handled with appropriate HTTP status codes. Tenant ID extracted from session only.
  </done>
</task>

</tasks>

<verification>
1. `pnpm test` passes for Apollo client tests
2. `pnpm tsc --noEmit` passes with zero errors
3. `pnpm build` succeeds — API route compiles
4. Filter translation correctly maps all 6 PersonaFilters fields to Apollo API params
5. Pagination caps at 500 pages (Apollo's limit)
6. Route returns 429 when rate limited, 503 when circuit breaker is open
7. Cache key includes tenantId (grep for `tenantId` in client.ts cache calls)
8. Route never reads tenant_id from request body or URL params
</verification>

<success_criteria>
- POST /api/search/apollo returns Apollo results with pagination metadata
- Rate limiting enforces 100 calls/hour per tenant
- Second identical search returns cached results (cached: true)
- Invalid requests get clear 400 error with validation details
- Unauthenticated requests get 401
- Persona not found gets 404
</success_criteria>

<output>
After completion, create `.planning/phases/02-persona-search-lists/02-03-SUMMARY.md`
</output>
