---
phase: 02-persona-search-lists
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/cache/redis.ts
  - src/lib/cache/keys.ts
  - src/lib/rate-limit/limiters.ts
  - src/lib/rate-limit/middleware.ts
  - src/lib/circuit-breaker/apollo-breaker.ts
  - src/lib/apollo/types.ts
  - src/lib/apollo/schemas.ts
autonomous: true
user_setup:
  - service: upstash-redis
    why: "Rate limiting and caching for Apollo API calls"
    env_vars:
      - name: UPSTASH_REDIS_REST_URL
        source: "Upstash Console -> Database -> REST API -> UPSTASH_REDIS_REST_URL"
      - name: UPSTASH_REDIS_REST_TOKEN
        source: "Upstash Console -> Database -> REST API -> UPSTASH_REDIS_REST_TOKEN"

must_haves:
  truths:
    - "Rate limiter enforces per-tenant limits (100 Apollo calls/hour)"
    - "Circuit breaker opens after 50% failure rate and returns fallback"
    - "Cache keys are always prefixed with tenant:{tenantId}:"
    - "Redis client is a singleton (no connection leaks)"
  artifacts:
    - path: "src/lib/cache/redis.ts"
      provides: "Redis client singleton"
      exports: ["redis"]
    - path: "src/lib/cache/keys.ts"
      provides: "Tenant-scoped cache key builder"
      exports: ["buildCacheKey", "getCachedData", "setCachedData"]
    - path: "src/lib/rate-limit/limiters.ts"
      provides: "Per-tenant rate limiters for Apollo API"
      exports: ["apolloRateLimiter"]
    - path: "src/lib/rate-limit/middleware.ts"
      provides: "Rate limit middleware for API routes"
      exports: ["withRateLimit"]
    - path: "src/lib/circuit-breaker/apollo-breaker.ts"
      provides: "Opossum circuit breaker for Apollo API"
      exports: ["apolloBreaker"]
    - path: "src/lib/apollo/types.ts"
      provides: "Apollo API request/response types"
      exports: ["ApolloSearchParams", "ApolloSearchResponse", "ApolloPerson"]
    - path: "src/lib/apollo/schemas.ts"
      provides: "Zod validation schemas for search API"
      exports: ["searchRequestSchema"]
  key_links:
    - from: "src/lib/rate-limit/limiters.ts"
      to: "src/lib/cache/redis.ts"
      via: "Redis client import"
      pattern: "import.*redis.*from.*cache/redis"
    - from: "src/lib/circuit-breaker/apollo-breaker.ts"
      to: "src/lib/apollo/types.ts"
      via: "Type imports for Apollo params/response"
      pattern: "import.*Apollo.*from.*apollo/types"
    - from: "src/lib/cache/keys.ts"
      to: "src/lib/cache/redis.ts"
      via: "Redis client for get/set operations"
      pattern: "import.*redis.*from.*redis"
---

<objective>
Set up the infrastructure layer for Phase 02: Redis caching, per-tenant rate limiting, circuit breaker for Apollo.io, and Apollo API types/validation schemas.

Purpose: All API routes in Phase 02 depend on rate limiting, caching, and circuit breaking. This plan creates the shared utilities that Plans 03-06 will import. Without this, API routes would be unprotected against rate limit overruns and cross-tenant cache pollution.

Output: 7 files providing Redis client, cache key builder, rate limiters, rate limit middleware, circuit breaker, Apollo types, and Zod validation schemas.
</objective>

<execution_context>
@/Users/aymanbaig/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aymanbaig/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-persona-search-lists/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Redis client, cache key builder, and cache utilities</name>
  <files>
    src/lib/cache/redis.ts
    src/lib/cache/keys.ts
  </files>
  <action>
Install dependencies:
```bash
pnpm add @upstash/redis @upstash/ratelimit opossum zod nuqs @tanstack/react-table
pnpm add -D @types/opossum
```

Create `src/lib/cache/redis.ts`:
- Import `Redis` from `@upstash/redis`
- Export a singleton Redis client using `Redis.fromEnv()` (reads UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN from env)
- Use module-level singleton pattern: `const redis = Redis.fromEnv(); export { redis };`

Create `src/lib/cache/keys.ts`:
- Import `redis` from `./redis`
- Import `createHash` from `crypto`
- Define `CacheKeyParams` interface: `{ tenantId: string; resource: string; identifier: string | object }`
- Export `buildCacheKey(params: CacheKeyParams): string` — builds key as `tenant:${tenantId}:${resource}:${hashedIdentifier}`. If identifier is string, use directly. If object, SHA-256 hash the JSON-stringified version (deterministic).
- Export `getCachedData<T>(params: CacheKeyParams): Promise<T | null>` — calls `redis.get<T>(buildCacheKey(params))`
- Export `setCachedData<T>(params: CacheKeyParams, data: T, ttl: number = 86400): Promise<void>` — calls `redis.set(key, JSON.stringify(data), { ex: ttl })`
- Export `invalidateCache(params: CacheKeyParams): Promise<void>` — calls `redis.del(buildCacheKey(params))`

IMPORTANT: The `buildCacheKey` function MUST always include `tenant:${tenantId}:` prefix. This is the primary defense against cross-tenant data leakage.
  </action>
  <verify>
Run `pnpm tsc --noEmit` — no type errors. Verify `buildCacheKey` function signature includes tenantId as required parameter (grep for `tenantId: string` in keys.ts).
  </verify>
  <done>
Redis client singleton exported. Cache key builder enforces tenant-scoped prefixes. getCachedData, setCachedData, and invalidateCache utilities available for import.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create rate limiters, rate limit middleware, circuit breaker, and Apollo types/schemas</name>
  <files>
    src/lib/rate-limit/limiters.ts
    src/lib/rate-limit/middleware.ts
    src/lib/circuit-breaker/apollo-breaker.ts
    src/lib/apollo/types.ts
    src/lib/apollo/schemas.ts
  </files>
  <action>
Create `src/lib/rate-limit/limiters.ts`:
- Import `Ratelimit` from `@upstash/ratelimit` and `redis` from `@/lib/cache/redis`
- Export `apolloRateLimiter` — `new Ratelimit({ redis, limiter: Ratelimit.slidingWindow(100, "1 h"), analytics: true, prefix: "ratelimit:apollo" })`
- This provides 100 Apollo API calls per hour per tenant

Create `src/lib/rate-limit/middleware.ts`:
- Export `withRateLimit(limiter: Ratelimit, identifier: string): Promise<{ success: boolean; limit: number; remaining: number; reset: number }>` — calls `limiter.limit(identifier)` and returns result
- Export `rateLimitHeaders(result: { limit: number; remaining: number; reset: number }): Headers` — returns Headers object with `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset`
- Export `rateLimitResponse(result: { limit: number; remaining: number; reset: number }): Response` — returns 429 Response with rate limit headers and JSON body `{ error: "Rate limit exceeded", resetAt: number }`

Create `src/lib/apollo/types.ts`:
- Export `ApolloSearchParams` interface: `{ person_titles?: string[]; person_seniorities?: string[]; organization_industries?: string[]; person_locations?: string[]; organization_num_employees_ranges?: string[]; q_keywords?: string; page: number; per_page: number }`
- Export `ApolloPerson` interface: `{ id: string; first_name: string; last_name: string; name: string; title: string; headline?: string; organization_name?: string; city?: string; state?: string; country?: string; email?: string; email_status?: string; phone_numbers?: { raw_number: string; sanitized_number?: string; type?: string }[]; linkedin_url?: string; photo_url?: string; employment_history?: { organization_name: string; title: string; current: boolean }[] }`
- Export `ApolloPagination` interface: `{ page: number; per_page: number; total_entries: number; total_pages: number }`
- Export `ApolloSearchResponse` interface: `{ people: ApolloPerson[]; pagination: ApolloPagination }`

Create `src/lib/apollo/schemas.ts`:
- Import `z` from `zod`
- Export `searchRequestSchema` — zod object with: `personaId: z.string().uuid()`, `page: z.number().int().min(1).max(500).default(1)`, `pageSize: z.number().int().min(10).max(100).default(50)`
- Export `PersonaFilters` zod schema: `{ titles: z.array(z.string()).optional(), seniorities: z.array(z.string()).optional(), industries: z.array(z.string()).optional(), locations: z.array(z.string()).optional(), companySize: z.array(z.string()).optional(), keywords: z.string().optional() }`

Create `src/lib/circuit-breaker/apollo-breaker.ts`:
- Import `CircuitBreaker` from `opossum`
- Import `ApolloSearchParams`, `ApolloSearchResponse` from `@/lib/apollo/types`
- Define internal `apolloSearchRequest(params: ApolloSearchParams): Promise<ApolloSearchResponse>` function:
  - Calls `fetch("https://api.apollo.io/api/v1/mixed_people/search", { method: "POST", headers: { "Content-Type": "application/json", "Cache-Control": "no-cache", "X-Api-Key": process.env.APOLLO_API_KEY! }, body: JSON.stringify(params) })`
  - On 429: throw `new Error("APOLLO_RATE_LIMIT_HIT")`
  - On other non-OK: throw `new Error(\`Apollo API error: ${response.status}\`)`
  - On success: return `response.json() as ApolloSearchResponse`
- Configure circuit breaker options: `timeout: 10000, errorThresholdPercentage: 50, resetTimeout: 30000, volumeThreshold: 5`
- Export `apolloBreaker = new CircuitBreaker(apolloSearchRequest, options)`
- Set fallback: `apolloBreaker.fallback(async () => ({ people: [], pagination: { page: 1, per_page: 50, total_entries: 0, total_pages: 0 } }))`
- Add event listeners for `open`, `halfOpen`, `close` that log to console with appropriate severity

NOTE: Apollo API uses `X-Api-Key` header (NOT `Authorization: Bearer`). The endpoint is `/api/v1/mixed_people/search` (NOT `/api_search`). Verify this against research doc.
  </action>
  <verify>
Run `pnpm tsc --noEmit` — no type errors. Verify all exports exist:
- `grep "export" src/lib/rate-limit/limiters.ts` shows `apolloRateLimiter`
- `grep "export" src/lib/circuit-breaker/apollo-breaker.ts` shows `apolloBreaker`
- `grep "export" src/lib/apollo/types.ts` shows all 4 interfaces
- `grep "export" src/lib/apollo/schemas.ts` shows `searchRequestSchema`
  </verify>
  <done>
Rate limiter enforces 100 Apollo calls/hour per tenant. Circuit breaker opens at 50% failure rate with 30s reset. Apollo types define complete request/response shapes. Zod schemas validate incoming search requests. Rate limit middleware provides reusable 429 response helpers.
  </done>
</task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` passes with zero errors
2. All 7 files exist at their specified paths
3. `buildCacheKey({ tenantId: "abc", resource: "test", identifier: "x" })` returns string starting with `tenant:abc:test:`
4. `apolloRateLimiter` is properly configured with sliding window (100, "1 h")
5. `apolloBreaker` has timeout of 10000ms, errorThresholdPercentage of 50
6. `searchRequestSchema` validates `{ personaId: "valid-uuid", page: 1, pageSize: 50 }` successfully
7. `searchRequestSchema` rejects `{ personaId: "not-a-uuid", page: 0 }` with validation errors
</verification>

<success_criteria>
- All infrastructure utilities compile without errors
- Rate limiter, circuit breaker, cache, and types are importable by downstream plans (03-06)
- No hardcoded tenant IDs anywhere — all functions accept tenantId as parameter
- Cache key builder enforces tenant prefix (impossible to create a key without tenantId)
</success_criteria>

<output>
After completion, create `.planning/phases/02-persona-search-lists/02-01-SUMMARY.md`
</output>
